<SOS>def euler015():<tab>関数euler015()は、以下の通り定義される<EOS>
<SOS>facts = [1] * 21<tab>factsを1のリストの21倍とする<EOS>
<SOS>for i in range(20):<tab>{{0から20未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>facts[i + 1] = facts[i] * (i + 1)<tab>factsの{{iに1を加えた値}}番目を{{factsのi番目に{{iに1を加えた値}}を掛けた値}}とする<EOS>
<SOS>dinomials = [0] * 21<tab>dinomialsを0のリストの21倍とする<EOS>
<SOS>for i in range(21):<tab>{{0から21未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>dinomials[i] = int(facts[20] / (facts[i] * facts[20 - i]))<tab>dinomialsのi番目を{{factsの20番目を{{factsのi番目にfactsの{{20からiを引いた値}}番目を掛けた値}}で割った値}}の整数値とする<EOS>
<SOS>for i in range(20):<tab>{{0から20未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>for j in range(20):<tab>{{0から20未満までの数列}}を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>dinomials[j] += dinomials[j + 1]<tab>dinomialsのj番目をdinomialsの{{jに1を加えた値}}番目だけ増加させる<EOS>
<SOS>return dinomials[0]<tab>dinomialsの先頭が関数出力となる<EOS>
<SOS>def euler015_combination(n, r):<tab>関数euler015_combination(n, r)は、以下の通り定義される<EOS>
<SOS>facts = [1] * (n + 1)<tab>factsを1のリストの{{nに1を加えた値}}倍とする<EOS>
<SOS>for x in range(n):<tab>{{0からn未満までの数列}}を先頭から順にxとして、以下を繰り返す<EOS>
<SOS>facts[x + 1] = facts[x] * (x + 1)<tab>factsの{{xに1を加えた値}}番目を{{factsのx番目に{{xに1を加えた値}}を掛けた値}}とする<EOS>
<SOS>return int(facts[n] / (facts[r] * facts[n - r]))<tab>{{factsのn番目を{{factsのr番目にfactsの{{nからrを引いた値}}番目を掛けた値}}で割った値}}の整数値が関数出力となる<EOS>
<SOS>def euler015_all_factorials(n):<tab>関数euler015_all_factorials(n)は、以下の通り定義される<EOS>
<SOS>facts = [1] * (n + 1)<tab>factsを1のリストの{{nに1を加えた値}}倍とする<EOS>
<SOS>for x in range(n):<tab>{{0からn未満までの数列}}を先頭から順にxとして、以下を繰り返す<EOS>
<SOS>facts[x + 1] = facts[x] * (x + 1)<tab>factsの{{xに1を加えた値}}番目を{{factsのx番目に{{xに1を加えた値}}を掛けた値}}とする<EOS>
<SOS>return facts<tab>factsが関数出力となる<EOS>
<SOS>def euler015_pascal_triangle(n):<tab>関数euler015_pascal_triangle(n)は、以下の通り定義される<EOS>
<SOS>if n == 1:<tab>もしnが1と等しいとき、<EOS>
<SOS>return [1]<tab>1のリストが関数出力となる<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>l = euler015_pascal_triangle(n - 1)<tab>lをeuler015_pascal_triangle({{nから1を引いた値}})とする<EOS>
<SOS>ret = [l[0], l[-1]]<tab>retをlの先頭とlの-1番目のリストとする<EOS>
<SOS>for i in range(n - 2):<tab>{{0から{{nから2を引いた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret.insert(i + 1, l[i] + l[i + 1])<tab>ret.insert(i + 1, l[i] + l[i + 1]) # retのi+1番目にlのi番目とi+1番目の要素の和を追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler014():<tab>関数euler014()は、以下の通り定義される<EOS>
<SOS>N = 10**6<tab>Nを{{10を6乗した値}}とする<EOS>
<SOS>cl = [-1] * N<tab>clを-1のリストのN倍とする<EOS>
<SOS>cl[1] = 0<tab>clの1番目を0とする<EOS>
<SOS>for n in range(2, N):<tab>{{2からN未満までの数列}}を先頭から順にnとして、以下を繰り返す<EOS>
<SOS>b = []<tab>bを空のリストとする<EOS>
<SOS>while n >= N or cl[n] == -1:<tab>もし{{nがN以上}}、または{{clのn番目が-1と等しいか}}のとき、以下を繰り返す<EOS>
<SOS>b.append(n)<tab>bにnを追加する<EOS>
<SOS>n = int(n / 2) if n % 2 == 0 else n * 3 + 1<tab>nをもし{{{{nを2で割った余り}}が0と等しいか}}のとき{{nを2で割った値}}の整数値、そうでなければ{{{{nに3を掛けた値}}に1を加えた値}}とする<EOS>
<SOS>l = cl[n]<tab>lをclのn番目とする<EOS>
<SOS>for m in reversed(b):<tab>{{bを反転した列}}を先頭から順にmとして、以下を繰り返す<EOS>
<SOS>l += 1<tab>lを1だけ増加させる<EOS>
<SOS>cl[m] = l<tab>clのm番目をlとする<EOS>
<SOS>ret = 0<tab>retを0とする<EOS>
<SOS>for i, n in enumerate(cl):<tab>{{clに番号をつける}}を先頭から順にiとnとして、以下を繰り返す<EOS>
<SOS>if m < n:<tab>もしmがnより小さいとき、以下のとおり<EOS>
<SOS>ret = i<tab>retをiとする<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler014_collatz_calc(n):<tab>関数euler014_collatz_calc(n)は、以下の通り定義される<EOS>
<SOS>return int(n / 2) if n % 2 == 0 else n * 3 + 1<tab>もし{{{{nを2で割った余り}}が0と等しいか}}のとき{{nを2で割った値}}の整数値、そうでなければ{{{{nに3を掛けた値}}に1を加えた値}}が関数出力となる<EOS>
<SOS>def euler014_collatz_problem_count(n):<tab>関数euler014_collatz_problem_count(n)は、以下の通り定義される<EOS>
<SOS>c = 0<tab>cを0とする<EOS>
<SOS>n = int(n / 2) if n % 2 == 0 else n * 3 + 1<tab>nをもし{{{{nを2で割った余り}}が0と等しいか}}のとき{{nを2で割った値}}の整数値、そうでなければ{{{{nに3を掛けた値}}に1を加えた値}}とする<EOS>
<SOS>return c<tab>cが関数出力となる<EOS>
<SOS>def euler014_list_init(l, n):<tab>関数euler014_list_init(l, n)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>ret.append(n)<tab>retにnを追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler014_list_enum(l):<tab>関数euler014_list_enum(l)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in range(len(l)):<tab>{{0からlの長さ未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret.append((i, l[i]))<tab>retにiとlのi番目の組を追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler014_list_reverse(l):<tab>関数euler014_list_reverse(l)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in reversed(l):<tab>{{lを反転した列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret.append(i)<tab>retにiを追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler014_make_range_list(s, e):<tab>関数euler014_make_range_list(s, e)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in range(s, e):<tab>{{sからe未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret.append(i)<tab>retにiを追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler016():<tab>関数euler016()は、以下の通り定義される<EOS>
<SOS>q = str(2**1000)<tab>qを{{2を1000乗した値}}の文字列とする<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for x in q:<tab>qを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>def euler016_all_digit_sum(n):<tab>関数euler016_all_digit_sum(n)は、以下の通り定義される<EOS>
<SOS>q = str(n)<tab>qをnの文字列とする<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for ch in q:<tab>qを先頭から順にchとして、以下を繰り返す<EOS>
<SOS>s += int(ch)<tab>sをchの整数値だけ増加させる<EOS>
<SOS>return s<tab>sが関数出力となる<EOS>
<SOS>def euler016_n_separate_digit(n):<tab>関数euler016_n_separate_digit(n)は、以下の通り定義される<EOS>
<SOS>ret = [n % 10]<tab>retを{{nを10で割った余り}}のリストとする<EOS>
<SOS>while int(n / 10) > 0:<tab>もし{{nを10で割った値}}の整数値が0より大きいとき、以下を繰り返す<EOS>
<SOS>n = int(n / 10)<tab>nを{{nを10で割った値}}の整数値とする<EOS>
<SOS>ret.insert(0, n % 10)<tab>ret.insert(0, n % 10) # retの先頭にnを10で割った余りを追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler016_a_exp_b(a, b):<tab>関数euler016_a_exp_b(a, b)は、以下の通り定義される<EOS>
<SOS>res = 1<tab>resを1とする<EOS>
<SOS>c = 0<tab>cを0とする<EOS>
<SOS>while c < b:<tab>もしcがbより小さいとき、以下を繰り返す<EOS>
<SOS>res *= a<tab>resをa倍にする<EOS>
<SOS>c += 1<tab>cを1だけ増加させる<EOS>
<SOS>return res<tab>resが関数出力となる<EOS>
<SOS>def euler016_a_exp_b_a(a, b):<tab>関数euler016_a_exp_b_a(a, b)は、以下の通り定義される<EOS>
<SOS>return a**b<tab>{{aをb乗した値}}が関数出力となる<EOS>
<SOS>def euler017():<tab>関数euler017()は、以下の通り定義される<EOS>
<SOS>ret = 0<tab>retを0とする<EOS>
<SOS>for n in range(1, 1001):<tab>{{1から1001未満までの数列}}を先頭から順にnとして、以下を繰り返す<EOS>
<SOS>ret += len(word[n])<tab>retをwordのn番目の長さだけ増加させる<EOS>
<SOS>elif len(str(n)) == 2:<tab>もしそうでなく、nの文字列の長さが2と等しいとき、以下のとおり<EOS>
<SOS>ret += len(twoword[int(n / 10)])<tab>retをtwowordの{{nを10で割った値}}の整数値番目の長さだけ増加させる<EOS>
<SOS>ret += len(word[n % 10])<tab>retをwordの{{nを10で割った余り}}番目の長さだけ増加させる<EOS>
<SOS>elif len(str(n)) == 3:<tab>もしそうでなく、nの文字列の長さが3と等しいとき、以下のとおり<EOS>
<SOS>ret += len(word[int(n / 100)])<tab>retをwordの{{nを100で割った値}}の整数値番目の長さだけ増加させる<EOS>
<SOS>ret += len("hundredand")<tab>retを"hundredand"の長さだけ増加させる<EOS>
<SOS>a = n % 100<tab>aを{{nを100で割った余り}}とする<EOS>
<SOS>if a != 0 and a <= 20:<tab>もし{{aが0と等しくないか}}、かつ{{aが20以下}}のとき、<EOS>
<SOS>ret += len(word[a])<tab>retをwordのa番目の長さだけ増加させる<EOS>
<SOS>elif a == 0:<tab>もしそうでなく、aが0と等しいとき、<EOS>
<SOS>ret -= 3<tab>retを3だけ減少させる<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>ret += len(twoword[int(a / 10)])<tab>retをtwowordの{{aを10で割った値}}の整数値番目の長さだけ増加させる<EOS>
<SOS>ret += len(word[a % 10])<tab>retをwordの{{aを10で割った余り}}番目の長さだけ増加させる<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>ret += len("onethousand")<tab>retを"onethousand"の長さだけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler017_digit_separate(n):<tab>関数euler017_digit_separate(n)は、以下の通り定義される<EOS>
<SOS>q = str(n)<tab>qをnの文字列とする<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for ch in q:<tab>qを先頭から順にchとして、以下を繰り返す<EOS>
<SOS>ret.append(int(ch))<tab>retにchの整数値を追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler017_digit_count(n):<tab>関数euler017_digit_count(n)は、以下の通り定義される<EOS>
<SOS>c = 1<tab>cを1とする<EOS>
<SOS>while int(n / 10) > 0:<tab>もし{{nを10で割った値}}の整数値が0より大きいとき、以下を繰り返す<EOS>
<SOS>n /= 10<tab>nを10分の一にする<EOS>
<SOS>c += 1<tab>cを1だけ増加させる<EOS>
<SOS>return c<tab>cが関数出力となる<EOS>
<SOS>def euler017_ones_to_string(n):<tab>関数euler017_ones_to_string(n)は、以下の通り定義される<EOS>
<SOS>return word[n % 10]<tab>wordの{{nを10で割った余り}}番目が関数出力となる<EOS>
<SOS>def euler017_is_equal(a, b):<tab>関数euler017_is_equal(a, b)は、以下の通り定義される<EOS>
<SOS>return a == b<tab>{{aがbと等しいか}}が関数出力となる<EOS>
<SOS>def euler017_divid_integer_part(a, b):<tab>関数euler017_divid_integer_part(a, b)は、以下の通り定義される<EOS>
<SOS>return int(a / b)<tab>{{aをbで割った値}}の整数値が関数出力となる<EOS>
<SOS>def euler017_string_length(s):<tab>関数euler017_string_length(s)は、以下の通り定義される<EOS>
<SOS>c = 0<tab>cを0とする<EOS>
<SOS>for ch in s:<tab>sを先頭から順にchとして、以下を繰り返す<EOS>
<SOS>c += 1<tab>cを1だけ増加させる<EOS>
<SOS>return c<tab>cが関数出力となる<EOS>
<SOS>def euler017_string_length_a(s):<tab>関数euler017_string_length_a(s)は、以下の通り定義される<EOS>
<SOS>return len(s)<tab>sの長さが関数出力となる<EOS>
<SOS>def euler013():<tab>関数euler013()は、以下の通り定義される<EOS>
<SOS>q = []<tab>qを空のリストとする<EOS>
<SOS>a = str(sum(q))<tab>aをqの総和の文字列とする<EOS>
<SOS>ret = ""<tab>retを""とする<EOS>
<SOS>for i, ch in enumerate(a):<tab>{{aに番号をつける}}を先頭から順にiとchとして、以下を繰り返す<EOS>
<SOS>if i < 10:<tab>もしiが10より小さいとき、<EOS>
<SOS>ret += ch<tab>retをchだけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler013_front_n_slice(s, n):<tab>関数euler013_front_n_slice(s, n)は、以下の通り定義される<EOS>
<SOS>ret = ""<tab>retを""とする<EOS>
<SOS>for i, ch in enumerate(s):<tab>{{sに番号をつける}}を先頭から順にiとchとして、以下を繰り返す<EOS>
<SOS>if i < n:<tab>もしiがnより小さいとき、<EOS>
<SOS>ret += ch<tab>retをchだけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler013_query_n_sum(q, n):<tab>関数euler013_query_n_sum(q, n)は、以下の通り定義される<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for i in range(n):<tab>{{0からn未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>s += q[i]<tab>sをqのi番目だけ増加させる<EOS>
<SOS>return s<tab>sが関数出力となる<EOS>
<SOS>def euler012():<tab>関数euler012()は、以下の通り定義される<EOS>
<SOS>s = 1<tab>sを1とする<EOS>
<SOS>c = 0<tab>cを0とする<EOS>
<SOS>pl = [2]<tab>plを2のリストとする<EOS>
<SOS>fl = [1] * 4 + [0] * 96<tab>flを1のリストの{{4に0のリストの96倍を加えた値}}倍とする<EOS>
<SOS>while c < 500:<tab>もしcが500より小さいとき、以下を繰り返す<EOS>
<SOS>tn = sum(range(1, s + 1))<tab>tnを{{1から{{sに1を加えた値}}未満までの数列}}の総和とする<EOS>
<SOS>if not s % 2:<tab>もし{{sを2で割った余り}}の反対のとき、<EOS>
<SOS>t = (int(s / 2), s + 1)<tab>tを{{sを2で割った値}}の整数値と{{sに1を加えた値}}の組とする<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>t = (s, int((s + 1) / 2))<tab>tをsと{{{{sに1を加えた値}}を2で割った値}}の整数値の組とする<EOS>
<SOS>fc = 1<tab>fcを1とする<EOS>
<SOS>for x in t:<tab>tを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>if len(fl) < x:<tab>もしflの長さがxより小さいとき、以下のとおり<EOS>
<SOS>l = [0] * (x - len(fl) + 1)<tab>lを0のリストの{{{{xからflの長さを引いた値}}に1を加えた値}}倍とする<EOS>
<SOS>fl += l<tab>flをlだけ増加させる<EOS>
<SOS>if not fl[x]:<tab>もしflのx番目の反対のとき、以下のとおり<EOS>
<SOS>nc = 1<tab>ncを1とする<EOS>
<SOS>for i in range(pl[-1], x + 1):<tab>{{plの-1番目から{{xに1を加えた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>for j in range(2, int(x**0.5) + 1):<tab>2から{{{{xを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>if i % j == 0:<tab>もし{{iをjで割った余り}}が0と等しいとき、<EOS>
<SOS>break<tab>この繰り返しを中断する<EOS>
<SOS>for i in pl:<tab>plを先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if i > int(tn / 2):<tab>もしiが{{tnを2で割った値}}の整数値より大きいとき、<EOS>
<SOS>break<tab>この繰り返しを中断する<EOS>
<SOS>if x % i == 0:<tab>もし{{xをiで割った余り}}が0と等しいとき、以下のとおり<EOS>
<SOS>j = 1<tab>jを1とする<EOS>
<SOS>a = tn<tab>aをtnとする<EOS>
<SOS>while a % i == 0:<tab>もし{{aをiで割った余り}}が0と等しいとき、以下を繰り返す<EOS>
<SOS>a /= i<tab>aをi分の一にする<EOS>
<SOS>j += 1<tab>jを1だけ増加させる<EOS>
<SOS>fl[x] = nc<tab>flのx番目をncとする<EOS>
<SOS>fc *= fl[x]<tab>fcをflのx番目倍にする<EOS>
<SOS>s += 1<tab>sを1だけ増加させる<EOS>
<SOS>c = fc<tab>cをfcとする<EOS>
<SOS>return tn<tab>tnが関数出力となる<EOS>
<SOS>def euler012_a_over_b(a, b):<tab>関数euler012_a_over_b(a, b)は、以下の通り定義される<EOS>
<SOS>return b < a<tab>{{bがaより小さいか}}が関数出力となる<EOS>
<SOS>def euler012_range_prime_enumerate(s, e):<tab>関数euler012_range_prime_enumerate(s, e)は、以下の通り定義される<EOS>
<SOS>pl = []<tab>plを空のリストとする<EOS>
<SOS>if s <= 1:<tab>もしsが1以下のとき、<EOS>
<SOS>s = 2<tab>sを2とする<EOS>
<SOS>for i in range(s, e + 1):<tab>{{sから{{eに1を加えた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>f = True<tab>fを真とする<EOS>
<SOS>for j in range(2, int(i**0.5) + 1):<tab>2から{{{{iを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>if i % j == 0:<tab>もし{{iをjで割った余り}}が0と等しいとき、<EOS>
<SOS>break<tab>この繰り返しを中断する<EOS>
<SOS>return pl<tab>plが関数出力となる<EOS>
<SOS>def euler012_is_coprime(a, b):<tab>関数euler012_is_coprime(a, b)は、以下の通り定義される<EOS>
<SOS>while b != 0:<tab>もしbが0と等しくないとき、以下を繰り返す<EOS>
<SOS>a, b = b, a % b<tab>aを{{aをbで割った余り}}とするbをbとする<EOS>
<SOS>return a == 1<tab>{{aが1と等しいか}}が関数出力となる<EOS>
<SOS>def euler012_count_division(n, a):<tab>関数euler012_count_division(n, a)は、以下の通り定義される<EOS>
<SOS>ret = 0<tab>retを0とする<EOS>
<SOS>while n % a == 0:<tab>もし{{nをaで割った余り}}が0と等しいとき、以下を繰り返す<EOS>
<SOS>n /= a<tab>nをa分の一にする<EOS>
<SOS>ret += 1<tab>retを1だけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler012_prime_factorize(n):<tab>関数euler012_prime_factorize(n)は、以下の通り定義される<EOS>
<SOS>primes = [True] * (n + 1)<tab>primesを真のリストの{{nに1を加えた値}}倍とする<EOS>
<SOS>p = []<tab>pを空のリストとする<EOS>
<SOS>for i in range(2, int(n**0.5) + 1):<tab>2から{{{{nを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if primes[i]:<tab>もしprimesのi番目のとき、<EOS>
<SOS>for j in range(i + i, n + 1, i):<tab>{{{{iにiを加えた値}}から{{nに1を加えた値}}未満までのi間隔の数列}}を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>primes[j] = False<tab>primesのj番目を偽とする<EOS>
<SOS>for i in range(2, n + 1):<tab>{{2から{{nに1を加えた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if primes[i]:<tab>もしprimesのi番目のとき、<EOS>
<SOS>p.append(i)<tab>pにiを追加する<EOS>
<SOS>fl = []<tab>flを空のリストとする<EOS>
<SOS>for x in p:<tab>pを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>if n % x == 0:<tab>もし{{nをxで割った余り}}が0と等しいとき、以下のとおり<EOS>
<SOS>a = n<tab>aをnとする<EOS>
<SOS>c = 0<tab>cを0とする<EOS>
<SOS>while a % x == 0:<tab>もし{{aをxで割った余り}}が0と等しいとき、以下を繰り返す<EOS>
<SOS>a /= x<tab>aをx分の一にする<EOS>
<SOS>c += 1<tab>cを1だけ増加させる<EOS>
<SOS>return fl<tab>flが関数出力となる<EOS>
<SOS>def euler012_nth_triangular_number(n):<tab>関数euler012_nth_triangular_number(n)は、以下の通り定義される<EOS>
<SOS>return sum(range(1, n + 1))<tab>{{1から{{nに1を加えた値}}未満までの数列}}の総和が関数出力となる<EOS>
<SOS>def euler012_next_triangular_number(tn):<tab>関数euler012_next_triangular_number(tn)は、以下の通り定義される<EOS>
<SOS>ret = 0<tab>retを0とする<EOS>
<SOS>c = 1<tab>cを1とする<EOS>
<SOS>while ret <= tn:<tab>もしretがtn以下のとき、以下を繰り返す<EOS>
<SOS>ret += c<tab>retをcだけ増加させる<EOS>
<SOS>c += 1<tab>cを1だけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler012_count_divisor(expl):<tab>関数euler012_count_divisor(expl)は、以下の通り定義される<EOS>
<SOS>ret = 1<tab>retを1とする<EOS>
<SOS>for x in expl:<tab>explを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>ret *= (x + 1)<tab>retを{{xに1を加えた値}}倍にする<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler012_is_list_empty(l):<tab>関数euler012_is_list_empty(l)は、以下の通り定義される<EOS>
<SOS>return not l<tab>lの反対が関数出力となる<EOS>
<SOS>def euler012_is_list_empty_a(l):<tab>関数euler012_is_list_empty_a(l)は、以下の通り定義される<EOS>
<SOS>return len(l) == 0<tab>{{lの長さが0と等しいか}}が関数出力となる<EOS>
<SOS>def euler010():<tab>関数euler010()は、以下の通り定義される<EOS>
<SOS>p = [True] * 2000000<tab>pを真のリストの2000000倍とする<EOS>
<SOS>for x in range(2, int(2000000**0.5) + 1):<tab>2から{{{{2000000を0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にxとして、以下を繰り返す<EOS>
<SOS>if p[x]:<tab>もしpのx番目のとき、<EOS>
<SOS>for i in range(2 * x, len(p), x):<tab>{{{{2にxを掛けた値}}からpの長さ未満までのx間隔の数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>p[i] = False<tab>pのi番目を偽とする<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in range(2, 2000000):<tab>{{2から2000000未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if p[i]:<tab>もしpのi番目のとき、<EOS>
<SOS>ret.append(i)<tab>retにiを追加する<EOS>
<SOS>return sum(ret)<tab>retの総和が関数出力となる<EOS>
<SOS>def euler010_enum_prime(n):<tab>関数euler010_enum_prime(n)は、以下の通り定義される<EOS>
<SOS>p = [True] * n<tab>pを真のリストのn倍とする<EOS>
<SOS>for x in range(2, int(n**0.5) + 1):<tab>2から{{{{nを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にxとして、以下を繰り返す<EOS>
<SOS>if p[x]:<tab>もしpのx番目のとき、<EOS>
<SOS>for i in range(2 * x, len(p), x):<tab>{{{{2にxを掛けた値}}からpの長さ未満までのx間隔の数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>p[i] = False<tab>pのi番目を偽とする<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in range(2, n):<tab>{{2からn未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if p[i]:<tab>もしpのi番目のとき、<EOS>
<SOS>ret.append(i)<tab>retにiを追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler010_n_is_prime(n):<tab>関数euler010_n_is_prime(n)は、以下の通り定義される<EOS>
<SOS>judge = True<tab>judgeを真とする<EOS>
<SOS>if n < 2:<tab>もしnが2より小さいとき、<EOS>
<SOS>return False<tab>偽が関数出力となる<EOS>
<SOS>elif n == 2:<tab>もしそうでなく、nが2と等しいとき、<EOS>
<SOS>return True<tab>真が関数出力となる<EOS>
<SOS>for i in range(2, int(n**0.5) + 1):<tab>2から{{{{nを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if judge and n % i == 0:<tab>もしjudge、かつ{{{{nをiで割った余り}}が0と等しいか}}のとき、<EOS>
<SOS>judge = False<tab>judgeを偽とする<EOS>
<SOS>return judge<tab>judgeが関数出力となる<EOS>
<SOS>def euler010_list_sum(l):<tab>関数euler010_list_sum(l)は、以下の通り定義される<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for x in l:<tab>lを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>s += x<tab>sをxだけ増加させる<EOS>
<SOS>return s<tab>sが関数出力となる<EOS>
<SOS>def euler010_list_sum_a(l):<tab>関数euler010_list_sum_a(l)は、以下の通り定義される<EOS>
<SOS>return sum(l)<tab>lの総和が関数出力となる<EOS>
<SOS>def euler010_n_multiple_list(s, e, d):<tab>関数euler010_n_multiple_list(s, e, d)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>while s < e:<tab>もしsがeより小さいとき、以下を繰り返す<EOS>
<SOS>ret.append(s)<tab>retにsを追加する<EOS>
<SOS>s += d<tab>sをdだけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>@TODO [#MultiString '""']<tab> [#MultiString '""']<EOS>
<SOS>def euler011():<tab>関数euler011()は、以下の通り定義される<EOS>
<SOS>grid = """""".split()<tab>gridを{{[#MultiString '""']を空白で分割した文字列リスト}}とする<EOS>
<SOS>q = []<tab>qを空のリストとする<EOS>
<SOS>for ch in grid:<tab>gridを先頭から順にchとして、以下を繰り返す<EOS>
<SOS>q.append(int(ch))<tab>qにchの整数値を追加する<EOS>
<SOS>m = 0<tab>mを0とする<EOS>
<SOS>for i in range(20):<tab>{{0から20未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>for j in range(20):<tab>{{0から20未満までの数列}}を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>if j <= 16:<tab>もしjが16以下のとき、以下のとおり<EOS>
<SOS>m = max(m, q[i*20+j] * q[i*20+j+1] * q[i*20+j+2] * q[i*20+j+3])<tab>mをmとqの{{{{iに20を掛けた値}}にjを加えた値}}番目にqの{{{{iに20を掛けた値}}にjを加えた値}}に1を加えた値番目を掛けた値にqの{{{{iに20を掛けた値}}にjを加えた値}}に2を加えた値番目を掛けた値にqの{{{{iに20を掛けた値}}にjを加えた値}}に3を加えた値番目を掛けた値の最大値とする<EOS>
<SOS>if i <= 16:<tab>もしiが16以下のとき、<EOS>
<SOS>m = max(m, q[i*20+j] * q[(i+1)*20+j+1] * q[(i+2)*20+j+2] * q[(i+3)*20+j+3])<tab>mをmとqの{{{{iに20を掛けた値}}にjを加えた値}}番目にqの{{{{iに1を加えた値}}に20を掛けた値}}にjを加えた値に1を加えた値番目を掛けた値にqの{{{{iに2を加えた値}}に20を掛けた値}}にjを加えた値に2を加えた値番目を掛けた値にqの{{{{iに3を加えた値}}に20を掛けた値}}にjを加えた値に3を加えた値番目を掛けた値の最大値とする<EOS>
<SOS>if 4 <= j and i <= 16:<tab>もし{{4がj以下}}、かつ{{iが16以下}}のとき、<EOS>
<SOS>m = max(m, q[i*20+j] * q[(i+1)*20+j-1] * q[(i+2)*20+j-2] * q[(i+3)*20+j-3])<tab>mをmとqの{{{{iに20を掛けた値}}にjを加えた値}}番目にqの{{{{iに1を加えた値}}に20を掛けた値}}にjを加えた値から1を引いた値番目を掛けた値にqの{{{{iに2を加えた値}}に20を掛けた値}}にjを加えた値から2を引いた値番目を掛けた値にqの{{{{iに3を加えた値}}に20を掛けた値}}にjを加えた値から3を引いた値番目を掛けた値の最大値とする<EOS>
<SOS>if i <= 16:<tab>もしiが16以下のとき、<EOS>
<SOS>m = max(m, q[i*20+j] * q[(i+1)*20+j] * q[(i+2)*20+j] * q[(i+3)*20+j])<tab>mをmとqの{{{{iに20を掛けた値}}にjを加えた値}}番目にqの{{{{iに1を加えた値}}に20を掛けた値}}にjを加えた値番目を掛けた値にqの{{{{iに2を加えた値}}に20を掛けた値}}にjを加えた値番目を掛けた値にqの{{{{iに3を加えた値}}に20を掛けた値}}にjを加えた値番目を掛けた値の最大値とする<EOS>
<SOS>return m<tab>mが関数出力となる<EOS>
<SOS>def euler011_less_or_equal(a, b):<tab>関数euler011_less_or_equal(a, b)は、以下の通り定義される<EOS>
<SOS>return a <= b<tab>{{aがb以下}}が関数出力となる<EOS>
<SOS>def euler011_less_or_equal_a(a, b):<tab>関数euler011_less_or_equal_a(a, b)は、以下の通り定義される<EOS>
<SOS>res = b - a<tab>resを{{bからaを引いた値}}とする<EOS>
<SOS>return res >= 0<tab>{{resが0以上}}が関数出力となる<EOS>
<SOS>def euler011_over_or_equal(a, b):<tab>関数euler011_over_or_equal(a, b)は、以下の通り定義される<EOS>
<SOS>return b <= a<tab>{{bがa以下}}が関数出力となる<EOS>
<SOS>def euler011_over_or_equal_a(a, b):<tab>関数euler011_over_or_equal_a(a, b)は、以下の通り定義される<EOS>
<SOS>res = b - a<tab>resを{{bからaを引いた値}}とする<EOS>
<SOS>return res <= 0<tab>{{resが0以下}}が関数出力となる<EOS>
<SOS>def euler011_string_space_split(s):<tab>関数euler011_string_space_split(s)は、以下の通り定義される<EOS>
<SOS>sl = []<tab>slを空のリストとする<EOS>
<SOS>buf = ""<tab>bufを""とする<EOS>
<SOS>for ch in s:<tab>sを先頭から順にchとして、以下を繰り返す<EOS>
<SOS>if ch == " ":<tab>もしchが" "と等しいとき、以下のとおり<EOS>
<SOS>sl.append(buf)<tab>slにbufを追加する<EOS>
<SOS>buf = ""<tab>bufを""とする<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>buf += ch<tab>bufをchだけ増加させる<EOS>
<SOS>sl.append(buf)<tab>slにbufを追加する<EOS>
<SOS>return sl<tab>slが関数出力となる<EOS>
<SOS>def euler011_zero_to_n_list(n):<tab>関数euler011_zero_to_n_list(n)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>a = 0<tab>aを0とする<EOS>
<SOS>while a < n:<tab>もしaがnより小さいとき、以下を繰り返す<EOS>
<SOS>ret.append(a)<tab>retにaを追加する<EOS>
<SOS>a += 1<tab>aを1だけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler011_zero_to_n_list_a(n):<tab>関数euler011_zero_to_n_list_a(n)は、以下の通り定義される<EOS>
<SOS>return list(range(n))<tab>{{0からn未満までの数列}}のリストが関数出力となる<EOS>
<SOS>def euler011_upward_point(x, y):<tab>関数euler011_upward_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x, y - 1)<tab>xと{{yから1を引いた値}}の組が関数出力となる<EOS>
<SOS>def euler011_downward_point(x, y):<tab>関数euler011_downward_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x, y + 1)<tab>xと{{yに1を加えた値}}の組が関数出力となる<EOS>
<SOS>def euler011_left_point(x, y):<tab>関数euler011_left_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x - 1, y)<tab>{{xから1を引いた値}}とyの組が関数出力となる<EOS>
<SOS>def euler011_right_point(x, y):<tab>関数euler011_right_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x + 1, y)<tab>{{xに1を加えた値}}とyの組が関数出力となる<EOS>
<SOS>def euler011_upper_left_point(x, y):<tab>関数euler011_upper_left_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x - 1, y - 1)<tab>{{xから1を引いた値}}と{{yから1を引いた値}}の組が関数出力となる<EOS>
<SOS>def euler011_upper_right_point(x, y):<tab>関数euler011_upper_right_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x + 1, y - 1)<tab>{{xに1を加えた値}}と{{yから1を引いた値}}の組が関数出力となる<EOS>
<SOS>def euler011_lower_left_point(x, y):<tab>関数euler011_lower_left_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x - 1, y + 1)<tab>{{xから1を引いた値}}と{{yに1を加えた値}}の組が関数出力となる<EOS>
<SOS>def euler011_lower_right_point(x, y):<tab>関数euler011_lower_right_point(x, y)は、以下の通り定義される<EOS>
<SOS>return (x + 1, y + 1)<tab>{{xに1を加えた値}}と{{yに1を加えた値}}の組が関数出力となる<EOS>
<SOS>def euler009():<tab>関数euler009()は、以下の通り定義される<EOS>
<SOS>for i in range(1, 1000):<tab>{{1から1000未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>for j in range(i, 1000):<tab>{{iから1000未満までの数列}}を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>for k in range(j, 1000):<tab>{{jから1000未満までの数列}}を先頭から順にkとして、以下を繰り返す<EOS>
<SOS>p = i * i + j * j<tab>pを{{{{iにiを掛けた値}}に{{jにjを掛けた値}}を加えた値}}とする<EOS>
<SOS>if p == k * k and i + j + k == 1000:<tab>もし{{pが{{kにkを掛けた値}}と等しいか}}、かつ{{{{iにjを加えた値}}にkを加えた値}}が1000と等しいとき、<EOS>
<SOS>return i * j * k<tab>{{{{iにjを掛けた値}}にkを掛けた値}}が関数出力となる<EOS>
<SOS>def euler009_is_pythagoras(a, b, c):<tab>関数euler009_is_pythagoras(a, b, c)は、以下の通り定義される<EOS>
<SOS>return a * a + b * b == c * c<tab>{{{{aにaを掛けた値}}に{{bにbを掛けた値}}を加えた値}}が{{cにcを掛けた値}}と等しいかが関数出力となる<EOS>
<SOS>def euler009_n_square(n):<tab>関数euler009_n_square(n)は、以下の通り定義される<EOS>
<SOS>return n * n<tab>{{nにnを掛けた値}}が関数出力となる<EOS>
<SOS>def euler009_n_square_a(n):<tab>関数euler009_n_square_a(n)は、以下の通り定義される<EOS>
<SOS>ret = 0<tab>retを0とする<EOS>
<SOS>for i in range(l):<tab>{{0からl未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret += n<tab>retをnだけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler009_is_sum_equation1000(tp):<tab>関数euler009_is_sum_equation1000(tp)は、以下の通り定義される<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for x in tp:<tab>tpを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>s += x<tab>sをxだけ増加させる<EOS>
<SOS>if m < N:<tab>もしmがNより小さいとき、<EOS>
<SOS>return s == 1000<tab>{{sが1000と等しいか}}が関数出力となる<EOS>
<SOS>def euler009_is_sum_equation1000_a(tp):<tab>関数euler009_is_sum_equation1000_a(tp)は、以下の通り定義される<EOS>
<SOS>return sum(tp) == 1000<tab>{{tpの総和が1000と等しいか}}が関数出力となる<EOS>
<SOS>def euler009_all_product(l):<tab>関数euler009_all_product(l)は、以下の通り定義される<EOS>
<SOS>ret = 1<tab>retを1とする<EOS>
<SOS>for a in l:<tab>lを先頭から順にaとして、以下を繰り返す<EOS>
<SOS>ret *= a<tab>retをa倍にする<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler008():<tab>関数euler008()は、以下の通り定義される<EOS>
<SOS>sl = []<tab>slを空のリストとする<EOS>
<SOS>for i in range(5):<tab>{{0から5未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>sl.append(int(s[i]))<tab>slにsのi番目の整数値を追加する<EOS>
<SOS>m = 1<tab>mを1とする<EOS>
<SOS>for i in sl:<tab>slを先頭から順にiとして、以下を繰り返す<EOS>
<SOS>m *= i<tab>mをi倍にする<EOS>
<SOS>for i in range(5, len(s)):<tab>{{5からsの長さ未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>sl.append(int(s[i]))<tab>slにsのi番目の整数値を追加する<EOS>
<SOS>sl.pop(0)<tab>sl.pop(0) # slの最初の要素を削除する<EOS>
<SOS>a = 1<tab>aを1とする<EOS>
<SOS>for j in sl:<tab>slを先頭から順にjとして、以下を繰り返す<EOS>
<SOS>a *= j<tab>aをj倍にする<EOS>
<SOS>m = max(m, a)<tab>mをmとaの最大値とする<EOS>
<SOS>return m<tab>mが関数出力となる<EOS>
<SOS>def euler008_all_product(l):<tab>関数euler008_all_product(l)は、以下の通り定義される<EOS>
<SOS>ret = 1<tab>retを1とする<EOS>
<SOS>for x in l:<tab>lを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>ret *= x<tab>retをx倍にする<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler008_list_slice(l, s, c):<tab>関数euler008_list_slice(l, s, c)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in range(c):<tab>{{0からc未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret.append(l[s + i])<tab>retにlの{{sにiを加えた値}}番目を追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler008_elem_max(a, b):<tab>関数euler008_elem_max(a, b)は、以下の通り定義される<EOS>
<SOS>return b if a < b else a<tab>{{もし{{aがbより小さいか}}のときb、そうでなければa}}が関数出力となる<EOS>
<SOS>def euler008_elem_max_a(a, b):<tab>関数euler008_elem_max_a(a, b)は、以下の通り定義される<EOS>
<SOS>return max(a, b)<tab>aとbの最大値が関数出力となる<EOS>
<SOS>def euler008_list_add(l, a):<tab>関数euler008_list_add(l, a)は、以下の通り定義される<EOS>
<SOS>tmp = [a]<tab>tmpをaのリストとする<EOS>
<SOS>l += tmp<tab>lをtmpだけ増加させる<EOS>
<SOS>return l<tab>lが関数出力となる<EOS>
<SOS>def euler008_list_add_a(l, a):<tab>関数euler008_list_add_a(l, a)は、以下の通り定義される<EOS>
<SOS>l.append(a)<tab>lにaを追加する<EOS>
<SOS>return l<tab>lが関数出力となる<EOS>
<SOS>def euler005():<tab>関数euler005()は、以下の通り定義される<EOS>
<SOS>prime = []<tab>primeを空のリストとする<EOS>
<SOS>for i in range(2, 20):<tab>{{2から20未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>l = []<tab>lを空のリストとする<EOS>
<SOS>for y in prime:<tab>primeを先頭から順にyとして、以下を繰り返す<EOS>
<SOS>l.append(y)<tab>lにyを追加する<EOS>
<SOS>if len(l) == 0:<tab>もしlの長さが0と等しいとき、<EOS>
<SOS>prime.append(i)<tab>primeにiを追加する<EOS>
<SOS>a = 1<tab>aを1とする<EOS>
<SOS>for p in prime:<tab>primeを先頭から順にpとして、以下を繰り返す<EOS>
<SOS>for i in range(int(20**(1/p))):<tab>{{0から{{20を{{1をpで割った値}}乗した値}}の整数値未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>a = a * p<tab>aを{{aにpを掛けた値}}とする<EOS>
<SOS>return a<tab>aが関数出力となる<EOS>
<SOS>def euler005_enum_prime(n):<tab>関数euler005_enum_prime(n)は、以下の通り定義される<EOS>
<SOS>prime = []<tab>primeを空のリストとする<EOS>
<SOS>for i in range(2, n + 1):<tab>{{2から{{nに1を加えた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>f = True<tab>fを真とする<EOS>
<SOS>for j in prime:<tab>primeを先頭から順にjとして、以下を繰り返す<EOS>
<SOS>if i % j == 0:<tab>もし{{iをjで割った余り}}が0と等しいとき、以下のとおり<EOS>
<SOS>f = False<tab>fを偽とする<EOS>
<SOS>break<tab>この繰り返しを中断する<EOS>
<SOS>if f:<tab>もしfのとき、<EOS>
<SOS>prime.append(i)<tab>primeにiを追加する<EOS>
<SOS>return prime<tab>primeが関数出力となる<EOS>
<SOS>def euler005_enum_prime_a(n):<tab>関数euler005_enum_prime_a(n)は、以下の通り定義される<EOS>
<SOS>primes = []<tab>primesを空のリストとする<EOS>
<SOS>for i in range(2, n + 1):<tab>{{2から{{nに1を加えた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if i == 2:<tab>もしiが2と等しいとき、<EOS>
<SOS>primes.append(i)<tab>primesにiを追加する<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>for j in range(2, int(i**0.5) + 1):<tab>2から{{{{iを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>if i % j == 0:<tab>もし{{iをjで割った余り}}が0と等しいとき、<EOS>
<SOS>break<tab>この繰り返しを中断する<EOS>
<SOS>return primes<tab>primesが関数出力となる<EOS>
<SOS>def euler005_enum_prime_b(n):<tab>関数euler005_enum_prime_b(n)は、以下の通り定義される<EOS>
<SOS>primes = [True] * (n + 1)<tab>primesを真のリストの{{nに1を加えた値}}倍とする<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in range(2, int(n**0.5) + 1):<tab>2から{{{{nを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if primes[i]:<tab>もしprimesのi番目のとき、<EOS>
<SOS>for j in range(i + i, n + 1, i):<tab>{{{{iにiを加えた値}}から{{nに1を加えた値}}未満までのi間隔の数列}}を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>primes[j] = False<tab>primesのj番目を偽とする<EOS>
<SOS>for i in range(2, n + 1):<tab>{{2から{{nに1を加えた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if primes[i]:<tab>もしprimesのi番目のとき、<EOS>
<SOS>ret.append(i)<tab>retにiを追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler005_expmax(p, n):<tab>関数euler005_expmax(p, n)は、以下の通り定義される<EOS>
<SOS>a = 1<tab>aを1とする<EOS>
<SOS>while a < n:<tab>もしaがnより小さいとき、以下を繰り返す<EOS>
<SOS>a *= p<tab>aをp倍にする<EOS>
<SOS>return int(a / p)<tab>{{aをpで割った値}}の整数値が関数出力となる<EOS>
<SOS>def euler005_expmax_a(p, n):<tab>関数euler005_expmax_a(p, n)は、以下の通り定義される<EOS>
<SOS>return p**int(n**(1/p))<tab>{{pを{{nを{{1をpで割った値}}乗した値}}の整数値乗した値}}が関数出力となる<EOS>
<SOS>def euler004():<tab>関数euler004()は、以下の通り定義される<EOS>
<SOS>ans = 0<tab>ansを0とする<EOS>
<SOS>for j in range(999, 99, -1):<tab>{{999から99未満までの-1間隔の数列}}を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>for i in range(999, 99, -1):<tab>{{999から99未満までの-1間隔の数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>s = (str)(j * i)<tab>sを(str)({{jにiを掛けた値}})とする<EOS>
<SOS>a = ""<tab>aを""とする<EOS>
<SOS>b = ""<tab>bを""とする<EOS>
<SOS>sep = (int)(len(s) / 2) + (len(s) % 2)<tab>sepを{{(int)({{sの長さを2で割った値}})に{{sの長さを2で割った余り}}を加えた値}}とする<EOS>
<SOS>for k in range(sep):<tab>{{0からsep未満までの数列}}を先頭から順にkとして、以下を繰り返す<EOS>
<SOS>a += s[k]<tab>aをsのk番目だけ増加させる<EOS>
<SOS>b += s[len(s) - k - 1]<tab>bをsの{{{{sの長さからkを引いた値}}から1を引いた値}}番目だけ増加させる<EOS>
<SOS>if a == b:<tab>もしaがbと等しいとき、<EOS>
<SOS>ans = max(ans, i * j)<tab>ansをansと{{iにjを掛けた値}}の最大値とする<EOS>
<SOS>return ans<tab>ansが関数出力となる<EOS>
<SOS>def euler004_n_slice(s, n):<tab>関数euler004_n_slice(s, n)は、以下の通り定義される<EOS>
<SOS>ret = ""<tab>retを""とする<EOS>
<SOS>for i in range(n):<tab>{{0からn未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret += s[i]<tab>retをsのi番目だけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler004_n_bslice(s, n):<tab>関数euler004_n_bslice(s, n)は、以下の通り定義される<EOS>
<SOS>ret = ""<tab>retを""とする<EOS>
<SOS>for i in range(n):<tab>{{0からn未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret += s[len(s) - 1 - i]<tab>retをsの{{{{sの長さから1を引いた値}}からiを引いた値}}番目だけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler004_is_equal(a, b):<tab>関数euler004_is_equal(a, b)は、以下の通り定義される<EOS>
<SOS>return a == b<tab>{{aがbと等しいか}}が関数出力となる<EOS>
<SOS>def euler004_half_digit(n):<tab>関数euler004_half_digit(n)は、以下の通り定義される<EOS>
<SOS>s = (str)(n)<tab>sを(str)(n)とする<EOS>
<SOS>a = len(s)<tab>aをsの長さとする<EOS>
<SOS>return (int)(a / 2) + (a % 2)<tab>{{(int)({{aを2で割った値}})に{{aを2で割った余り}}を加えた値}}が関数出力となる<EOS>
<SOS>def euler004_multiple(a, b):<tab>関数euler004_multiple(a, b)は、以下の通り定義される<EOS>
<SOS>return a * b<tab>{{aにbを掛けた値}}が関数出力となる<EOS>
<SOS>def euler004_multiple_a(a, b):<tab>関数euler004_multiple_a(a, b)は、以下の通り定義される<EOS>
<SOS>res = 0<tab>resを0とする<EOS>
<SOS>for i in range(b):<tab>{{0からb未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>res += a<tab>resをaだけ増加させる<EOS>
<SOS>return res<tab>resが関数出力となる<EOS>
<SOS>def euler004_string_reverse(s):<tab>関数euler004_string_reverse(s)は、以下の通り定義される<EOS>
<SOS>ret = ""<tab>retを""とする<EOS>
<SOS>for ch in reversed(s):<tab>{{sを反転した列}}を先頭から順にchとして、以下を繰り返す<EOS>
<SOS>ret += ch<tab>retをchだけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler004_is_palindromic(s):<tab>関数euler004_is_palindromic(s)は、以下の通り定義される<EOS>
<SOS>rs = ""<tab>rsを""とする<EOS>
<SOS>for ch in reversed(s):<tab>{{sを反転した列}}を先頭から順にchとして、以下を繰り返す<EOS>
<SOS>rs += ch<tab>rsをchだけ増加させる<EOS>
<SOS>return s == rs<tab>{{sがrsと等しいか}}が関数出力となる<EOS>
<SOS>def euler006():<tab>関数euler006()は、以下の通り定義される<EOS>
<SOS>sumofsq = 0<tab>sumofsqを0とする<EOS>
<SOS>for i in range(100):<tab>{{0から100未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>sumofsq += (i + 1) * (i + 1)<tab>sumofsqを{{{{iに1を加えた値}}に{{iに1を加えた値}}を掛けた値}}だけ増加させる<EOS>
<SOS>sqofsum = 101 * 50<tab>sqofsumを{{101に50を掛けた値}}とする<EOS>
<SOS>return sumofsq - sqofsum<tab>{{sumofsqからsqofsumを引いた値}}が関数出力となる<EOS>
<SOS>def euler006_make_common_diff_sequence(s, d, n):<tab>関数euler006_make_common_diff_sequence(s, d, n)は、以下の通り定義される<EOS>
<SOS>ret = [s]<tab>retをsのリストとする<EOS>
<SOS>for i in range(n - 1):<tab>{{0から{{nから1を引いた値}}未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret.append(ret[-1] + d)<tab>retに{{retの-1番目にdを加えた値}}を追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler006_make_common_diff_sequence_a(s, d, n):<tab>関数euler006_make_common_diff_sequence_a(s, d, n)は、以下の通り定義される<EOS>
<SOS>ret = []<tab>retを空のリストとする<EOS>
<SOS>for i in range(s, s + (d * n), d):<tab>{{sから{{sに{{dにnを掛けた値}}を加えた値}}未満までのd間隔の数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret.append(i)<tab>retにiを追加する<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler006_n_square(n):<tab>関数euler006_n_square(n)は、以下の通り定義される<EOS>
<SOS>return n * n<tab>{{nにnを掛けた値}}が関数出力となる<EOS>
<SOS>def euler006_n_square_a(n):<tab>関数euler006_n_square_a(n)は、以下の通り定義される<EOS>
<SOS>ret = 0<tab>retを0とする<EOS>
<SOS>for i in range(n):<tab>{{0からn未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>ret += n<tab>retをnだけ増加させる<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler006_sum_a_to_b(a, b):<tab>関数euler006_sum_a_to_b(a, b)は、以下の通り定義される<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>while a < b:<tab>もしaがbより小さいとき、以下を繰り返す<EOS>
<SOS>s += a<tab>sをaだけ増加させる<EOS>
<SOS>a += 1<tab>aを1だけ増加させる<EOS>
<SOS>return s<tab>sが関数出力となる<EOS>
<SOS>def euler006_sum_a_to_b_a(a, b):<tab>関数euler006_sum_a_to_b_a(a, b)は、以下の通り定義される<EOS>
<SOS>return sum(range(a, b))<tab>{{aからb未満までの数列}}の総和が関数出力となる<EOS>
<SOS>@TODO [#ListForExpr append: [#Name 'i'][#ForExpr each: [#Name 'i']list: [#ApplyExpr name: [#Name 'range']params: [#Arguments [#Int '2'][#Infix left: [#ApplyExpr name: [#Name 'int']params: [#Arguments [#MethodExpr recv: [#Name 'math']name: [#Name 'sqrt']params: [#Arguments [#Name 'p']]]]]name: [#Name '+']right: [#Int '1']]]]cond: [#Infix left: [#Infix left: [#Name 'p']name: [#Name '%']right: [#Name 'i']]name: [#Name '==']right: [#Int '0']]]]<tab> [#ListForExpr append: [#Name 'i'][#ForExpr each: [#Name 'i']list: [#ApplyExpr name: [#Name 'range']params: [#Arguments [#Int '2'][#Infix left: [#ApplyExpr name: [#Name 'int']params: [#Arguments [#MethodExpr recv: [#Name 'math']name: [#Name 'sqrt']params: [#Arguments [#Name 'p']]]]]name: [#Name '+']right: [#Int '1']]]]cond: [#Infix left: [#Infix left: [#Name 'p']name: [#Name '%']right: [#Name 'i']]name: [#Name '==']right: [#Int '0']]]]<EOS>
<SOS>def euler007():<tab>関数euler007()は、以下の通り定義される<EOS>
<SOS>count = 0<tab>countを0とする<EOS>
<SOS>p = 1<tab>pを1とする<EOS>
<SOS>pl = []<tab>plを空のリストとする<EOS>
<SOS>while count < 10001:<tab>もしcountが10001より小さいとき、以下を繰り返す<EOS>
<SOS>p += 1<tab>pを1だけ増加させる<EOS>
<SOS>l = [ i for i in range(2, int(math.sqrt(p)) + 1) if p % i == 0 ]<tab>lを[#ListForExpr append: [#Name 'i'][#ForExpr each: [#Name 'i']list: [#ApplyExpr name: [#Name 'range']params: [#Arguments [#Int '2'][#Infix left: [#ApplyExpr name: [#Name 'int']params: [#Arguments [#MethodExpr recv: [#Name 'math']name: [#Name 'sqrt']params: [#Arguments [#Name 'p']]]]]name: [#Name '+']right: [#Int '1']]]]cond: [#Infix left: [#Infix left: [#Name 'p']name: [#Name '%']right: [#Name 'i']]name: [#Name '==']right: [#Int '0']]]]とする<EOS>
<SOS>if len(l) == 0:<tab>もしlの長さが0と等しいとき、<EOS>
<SOS>count += 1<tab>countを1だけ増加させる<EOS>
<SOS>return p<tab>pが関数出力となる<EOS>
<SOS>def euler007_n_division(a, n):<tab>関数euler007_n_division(a, n)は、以下の通り定義される<EOS>
<SOS>return a % n == 0<tab>{{{{aをnで割った余り}}が0と等しいか}}が関数出力となる<EOS>
<SOS>def euler007_n_division_a(a, n):<tab>関数euler007_n_division_a(a, n)は、以下の通り定義される<EOS>
<SOS>while a > 0:<tab>もしaが0より大きいとき、以下を繰り返す<EOS>
<SOS>a -= n<tab>aをnだけ減少させる<EOS>
<SOS>return a == 0<tab>{{aが0と等しいか}}が関数出力となる<EOS>
<SOS>def euler007_is_prime(a):<tab>関数euler007_is_prime(a)は、以下の通り定義される<EOS>
<SOS>dl = []<tab>dlを空のリストとする<EOS>
<SOS>for i in range(2, a):<tab>{{2からa未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if a % i == 0:<tab>もし{{aをiで割った余り}}が0と等しいとき、<EOS>
<SOS>dl.append(i)<tab>dlにiを追加する<EOS>
<SOS>return len(dl) == 0<tab>{{dlの長さが0と等しいか}}が関数出力となる<EOS>
<SOS>def euler007_is_prime_a(a):<tab>関数euler007_is_prime_a(a)は、以下の通り定義される<EOS>
<SOS>if a < 2:<tab>もしaが2より小さいとき、<EOS>
<SOS>return False<tab>偽が関数出力となる<EOS>
<SOS>elif a == 2:<tab>もしそうでなく、aが2と等しいとき、<EOS>
<SOS>return True<tab>真が関数出力となる<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>for i in range(2, int(a**0.5) + 1):<tab>2から{{{{aを0.5乗した値}}の整数値に1を加えた値}}未満までの数列を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>if a % i == 0:<tab>もし{{aをiで割った余り}}が0と等しいとき、<EOS>
<SOS>return False<tab>偽が関数出力となる<EOS>
<SOS>return True<tab>真が関数出力となる<EOS>
<SOS>def euler007_succ(a):<tab>関数euler007_succ(a)は、以下の通り定義される<EOS>
<SOS>return a + 1<tab>{{aに1を加えた値}}が関数出力となる<EOS>
<SOS>def euler007_is_less(a, b):<tab>関数euler007_is_less(a, b)は、以下の通り定義される<EOS>
<SOS>return a < b<tab>{{aがbより小さいか}}が関数出力となる<EOS>
<SOS>def euler007_is_equale_zero(a):<tab>関数euler007_is_equale_zero(a)は、以下の通り定義される<EOS>
<SOS>return a == 0<tab>{{aが0と等しいか}}が関数出力となる<EOS>
<SOS>def euler003():<tab>関数euler003()は、以下の通り定義される<EOS>
<SOS>n = 600851475143<tab>nを600851475143とする<EOS>
<SOS>i = 2<tab>iを2とする<EOS>
<SOS>while i * i < n:<tab>もし{{iにiを掛けた値}}がnより小さいとき、以下を繰り返す<EOS>
<SOS>while n % i == 0:<tab>もし{{nをiで割った余り}}が0と等しいとき、以下を繰り返す<EOS>
<SOS>n = n / i<tab>nを{{nをiで割った値}}とする<EOS>
<SOS>i = i + 1<tab>iを{{iに1を加えた値}}とする<EOS>
<SOS>return int(n)<tab>nの整数値が関数出力となる<EOS>
<SOS>def euler003_n_morethan_square(a, n):<tab>関数euler003_n_morethan_square(a, n)は、以下の通り定義される<EOS>
<SOS>return a * a < n<tab>{{{{aにaを掛けた値}}がnより小さいか}}が関数出力となる<EOS>
<SOS>def euler003_n_divide_a(n, a):<tab>関数euler003_n_divide_a(n, a)は、以下の通り定義される<EOS>
<SOS>while n % a == 0:<tab>もし{{nをaで割った余り}}が0と等しいとき、以下を繰り返す<EOS>
<SOS>n /= a<tab>nをa分の一にする<EOS>
<SOS>return int(n)<tab>nの整数値が関数出力となる<EOS>
<SOS>def euler002():<tab>関数euler002()は、以下の通り定義される<EOS>
<SOS>fib = [1, 2]<tab>fibを1と2のリストとする<EOS>
<SOS>while fib[-1] < 4000000:<tab>もしfibの-1番目が4000000より小さいとき、以下を繰り返す<EOS>
<SOS>fib.append(fib[-1] + fib[-2])<tab>fibに{{fibの-1番目にfibの-2番目を加えた値}}を追加する<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for x in fib:<tab>fibを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>if x % 2 == 0:<tab>もし{{xを2で割った余り}}が0と等しいとき、<EOS>
<SOS>s += x<tab>sをxだけ増加させる<EOS>
<SOS>return s<tab>sが関数出力となる<EOS>
<SOS>def euler002_divide_2(n):<tab>関数euler002_divide_2(n)は、以下の通り定義される<EOS>
<SOS>return n % 2 == 0<tab>{{{{nを2で割った余り}}が0と等しいか}}が関数出力となる<EOS>
<SOS>def euler002_add_param(a, b):<tab>関数euler002_add_param(a, b)は、以下の通り定義される<EOS>
<SOS>return a + b<tab>{{aにbを加えた値}}が関数出力となる<EOS>
<SOS>def euler002_sum_list(l):<tab>関数euler002_sum_list(l)は、以下の通り定義される<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for x in l:<tab>lを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>s += x<tab>sをxだけ増加させる<EOS>
<SOS>return s<tab>sが関数出力となる<EOS>
<SOS>def euler002_sum_list_a(l):<tab>関数euler002_sum_list_a(l)は、以下の通り定義される<EOS>
<SOS>return sum(l)<tab>lの総和が関数出力となる<EOS>
<SOS>def euler002_n_fibnocci_sequence(n):<tab>関数euler002_n_fibnocci_sequence(n)は、以下の通り定義される<EOS>
<SOS>fibs = [0, 1]<tab>fibsを0と1のリストとする<EOS>
<SOS>a = n - 2<tab>aを{{nから2を引いた値}}とする<EOS>
<SOS>if n == 1:<tab>もしnが1と等しいとき、<EOS>
<SOS>return [0]<tab>0のリストが関数出力となる<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>while a > 0:<tab>もしaが0より大きいとき、以下を繰り返す<EOS>
<SOS>fibs.append(fibs[-1] + fibs[-2])<tab>fibsに{{fibsの-1番目にfibsの-2番目を加えた値}}を追加する<EOS>
<SOS>a -= 1<tab>aを1だけ減少させる<EOS>
<SOS>return fibs<tab>fibsが関数出力となる<EOS>
<SOS>def euler002_n_fibnocci_number(n):<tab>関数euler002_n_fibnocci_number(n)は、以下の通り定義される<EOS>
<SOS>fibs = [0, 1]<tab>fibsを0と1のリストとする<EOS>
<SOS>if 0 < n <= 2:<tab>もし{{0がnより小さいか}}が2以下のとき、<EOS>
<SOS>return fibs[n - 1]<tab>fibsの{{nから1を引いた値}}番目が関数出力となる<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>a = n - 2 <tab>aを{{nから2を引いた値}}とする<EOS>
<SOS>while a > 0:<tab>もしaが0より大きいとき、以下を繰り返す<EOS>
<SOS>fibs.append(fibs[-1] + fibs[-2])<tab>fibsに{{fibsの-1番目にfibsの-2番目を加えた値}}を追加する<EOS>
<SOS>a -= 1<tab>aを1だけ減少させる<EOS>
<SOS>return fibs[-1]<tab>fibsの-1番目が関数出力となる<EOS>
<SOS>def euler020():<tab>関数euler020()は、以下の通り定義される<EOS>
<SOS>fact = 1<tab>factを1とする<EOS>
<SOS>for i in range(100):<tab>{{0から100未満までの数列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>fact *= (i + 1)<tab>factを{{iに1を加えた値}}倍にする<EOS>
<SOS>s = str(fact)<tab>sをfactの文字列とする<EOS>
<SOS>q = []<tab>qを空のリストとする<EOS>
<SOS>for ch in s:<tab>sを先頭から順にchとして、以下を繰り返す<EOS>
<SOS>q.append(int(ch))<tab>qにchの整数値を追加する<EOS>
<SOS>return sum(q)<tab>qの総和が関数出力となる<EOS>
<SOS>def euler020_factorial(n):<tab>関数euler020_factorial(n)は、以下の通り定義される<EOS>
<SOS>ret = 1<tab>retを1とする<EOS>
<SOS>for x in range(n):<tab>{{0からn未満までの数列}}を先頭から順にxとして、以下を繰り返す<EOS>
<SOS>ret *= (x + 1)<tab>retを{{xに1を加えた値}}倍にする<EOS>
<SOS>return ret<tab>retが関数出力となる<EOS>
<SOS>def euler020_digit_sum(n):<tab>関数euler020_digit_sum(n)は、以下の通り定義される<EOS>
<SOS>q = str(n)<tab>qをnの文字列とする<EOS>
<SOS>s = 0<tab>sを0とする<EOS>
<SOS>for x in q:<tab>qを先頭から順にxとして、以下を繰り返す<EOS>
<SOS>s += int(x)<tab>sをxの整数値だけ増加させる<EOS>
<SOS>return s<tab>sが関数出力となる<EOS>
<SOS>def euler019():<tab>関数euler019()は、以下の通り定義される<EOS>
<SOS>d = 365<tab>dを365とする<EOS>
<SOS>for y in range(1901, 2001):<tab>{{1901から2001未満までの数列}}を先頭から順にyとして、以下を繰り返す<EOS>
<SOS>for i, day in enumerate(days):<tab>{{daysに番号をつける}}を先頭から順にiとdayとして、以下を繰り返す<EOS>
<SOS>if d % 7 == 6:<tab>もし{{dを7で割った余り}}が6と等しいとき、<EOS>
<SOS>sd += 1<tab>sdを1だけ増加させる<EOS>
<SOS>d += day <tab>dをdayだけ増加させる<EOS>
<SOS>if (y % 400 == 0 or ((not y % 100 == 0) and y % 4 == 0)) and i == 1:<tab>もし{{{{yを400で割った余り}}が0と等しいか}}、または{{{{yを100で割った余り}}が0と等しいか}}の反対、かつ{{{{yを4で割った余り}}が0と等しいか}}、かつ{{iが1と等しいか}}のとき、<EOS>
<SOS>d += 1<tab>dを1だけ増加させる<EOS>
<SOS>return sd<tab>sdが関数出力となる<EOS>
<SOS>def euler019_is_leap_year(y):<tab>関数euler019_is_leap_year(y)は、以下の通り定義される<EOS>
<SOS>return y % 400 == 0 or ((not y % 100 == 0) and y % 4 == 0)<tab>{{{{yを400で割った余り}}が0と等しいか}}、または{{{{yを100で割った余り}}が0と等しいか}}の反対、かつ{{{{yを4で割った余り}}が0と等しいか}}が関数出力となる<EOS>
<SOS>def euler019_names_of_the_day(y, m, d):<tab>関数euler019_names_of_the_day(y, m, d)は、以下の通り定義される<EOS>
<SOS>if m <= 2:<tab>もしmが2以下のとき、以下のとおり<EOS>
<SOS>m += 12<tab>mを12だけ増加させる<EOS>
<SOS>y -= 1<tab>yを1だけ減少させる<EOS>
<SOS>gamma = 0<tab>gammaを0とする<EOS>
<SOS>if 1582 <= y:<tab>もし1582がy以下のとき、<EOS>
<SOS>gamma = -2 * int(y / 100) + int( int(y / 100) / 4 )<tab>gammaを{{{{-2に{{yを100で割った値}}の整数値を掛けた値}}に{{{{yを100で割った値}}の整数値を4で割った値}}の整数値を加えた値}}とする<EOS>
<SOS>もしそうでなければ、<tab>なければ、<EOS>
<SOS>gamma = -1 * int(y / 100) + 5<tab>gammaを{{{{-1に{{yを100で割った値}}の整数値を掛けた値}}に5を加えた値}}とする<EOS>
<SOS>h = (d + int(26 * (m + 1) / 10) + (y % 100) + int((y % 100) / 4) + gamma) % 7<tab>hを{{dに{{{{26に{{mに1を加えた値}}を掛けた値}}を10で割った値}}の整数値を加えた値}}に{{yを100で割った余り}}を加えた値に{{{{yを100で割った余り}}を4で割った値}}の整数値を加えた値にgammaを加えた値を7で割った余りとする<EOS>
<SOS>return name[h]<tab>nameのh番目が関数出力となる<EOS>
<SOS>def euler018():<tab>関数euler018()は、以下の通り定義される<EOS>
<SOS>for i in reversed(range(len(tri) - 1)):<tab>{{{{0から{{triの長さから1を引いた値}}未満までの数列}}を反転した列}}を先頭から順にiとして、以下を繰り返す<EOS>
<SOS>for j in range(len(tri[i])):<tab>{{0からtriのi番目の長さ未満までの数列}}を先頭から順にjとして、以下を繰り返す<EOS>
<SOS>tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1])<tab>triのi番目のj番目をtriの{{iに1を加えた値}}番目のj番目とtriの{{iに1を加えた値}}番目の{{jに1を加えた値}}番目の最大値だけ増加させる<EOS>
<SOS>return tri[0][0]<tab>triの先頭の先頭が関数出力となる<EOS>
<SOS>print("Hello World")<tab>"Hello World"を出力する<EOS>
<SOS>x = int(input())<tab>入力された文字列の整数値をxとする<EOS>
<SOS>print(x ** 3)<tab>xの3乗を出力する<EOS>
<SOS>W = int(input())<tab>入力された文字列の整数値をWとする<EOS>
<SOS>print(W * 32)<tab>Wに32を掛けた値を出力する<EOS>
<SOS>F = int(input())<tab>入力された文字列の整数値をFとする<EOS>
<SOS>print((F - 30) // 2)<tab>({{Fから30を引いた値}})の組を2で割った商を出力する<EOS>
<SOS>p, m, c  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にp、m、cとする<EOS>
<SOS>print(p + m + c)<tab>{{pにmを加えた値}}にcを加えた値を出力する<EOS>
<SOS>a, b  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にaとbとする<EOS>
<SOS>s = a * b<tab>aにbを掛けた値をsとする<EOS>
<SOS>l = a * 2 + b * 2<tab>aに2を掛けた値にbに2を掛けた値を加えた値をlとする<EOS>
<SOS>print(s, l)<tab>sとlを出力する<EOS>
<SOS>a, b  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にaとbとする<EOS>
<SOS>if a == b  :<tab>aがbのとき、<EOS>
<SOS>print("a == b")<tab>"a == b"を出力する<EOS>
<SOS>elif a < b  :<tab>('aがbより小さい',)<EOS>
<SOS>print("a < b")<tab>"a < b"を出力する<EOS>
<SOS>a, b, c  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にa、b、cとする<EOS>
<SOS>if a < b and b < c  :<tab>aがbより小さく、かつbがcより小さいとき、<EOS>
<SOS>print("Yes")<tab>"Yes"を出力する<EOS>
<SOS>a, b  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にaとbとする<EOS>
<SOS>print((a + b) // 2)<tab>({{aにbを加えた値}})の組を2で割った商を出力する<EOS>
<SOS>x1, x2  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にx1とx2とする<EOS>
<SOS>print(abs(x1 - x2))<tab>{{x1からx2を引いた値}}の絶対値を出力する<EOS>
<SOS>B = input()<tab>入力された文字列をBとする<EOS>
<SOS>O = ["1 1 0", "0 0 1"]<tab>("1 1 0"と"0 0 1")からなる列をOとする<EOS>
<SOS>if B in O  :<tab>BがOに含まれるとき、<EOS>
<SOS>print("Open")<tab>"Open"を出力する<EOS>
<SOS>S = int(input())<tab>入力された文字列の整数値をSとする<EOS>
<SOS>h = S // 3600<tab>Sを3600で割った商をhとする<EOS>
<SOS>m = (S - h * 3600) // 60<tab>({{Sから{{hに3600を掛けた値}}を引いた値}})の組を60で割った商をmとする<EOS>
<SOS>s = S - (h * 3600 + m * 60)<tab>Sから({{{{hに3600を掛けた値}}に{{mに60を掛けた値}}を加えた値}})の組を引いた値をsとする<EOS>
<SOS>print(h, ":", m, ":", s, sep = "")<tab>h、":"、m、":"、s、((sep, ""))からなる辞書を出力する<EOS>
<SOS>a, b, c  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にa、b、cとする<EOS>
<SOS>if a < b  :<tab>aがbより小さいとき、<EOS>
<SOS>if b < c  :<tab>bがcより小さいとき、<EOS>
<SOS>print(a, b, c)<tab>a、b、cを出力する<EOS>
<SOS>elif a < c  :<tab>('aがcより小さい',)<EOS>
<SOS>print(a, c, b)<tab>a、c、bを出力する<EOS>
<SOS>elif b < a  :<tab>('bがaより小さい',)<EOS>
<SOS>if a < c  :<tab>aがcより小さいとき、<EOS>
<SOS>print(b, a, c)<tab>b、a、cを出力する<EOS>
<SOS>elif b < c  :<tab>('bがcより小さい',)<EOS>
<SOS>print(b, c, a)<tab>b、c、aを出力する<EOS>
<SOS>W, H, x, y, r  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にW、H、x、y、rとする<EOS>
<SOS>if x - r >= 0 and y - r >= 0  :<tab>{{xからrを引いた値}}が0以上、かつ{{yからrを引いた値}}が0以上のとき、<EOS>
<SOS>if x + r <= W and y + r <= H  :<tab>{{xにrを加えた値}}がW以下、かつ{{yにrを加えた値}}がH以下のとき、<EOS>
<SOS>print("Yes")<tab>"Yes"を出力する<EOS>
<SOS>e1, e2, e3, e4  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にe1、e2、e3、e4とする<EOS>
<SOS>E = [e1, e2, e3, e4]<tab>(e1、e2、e3、e4)からなる列をEとする<EOS>
<SOS>e = set(E)<tab>Eの集合をeとする<EOS>
<SOS>e_list = list(e)<tab>'eのリストをe_listとする<EOS>
<SOS>if len(e) == 2  :<tab>eの長さが2のとき、<EOS>
<SOS>if E.count(e_list[0]) == 2  :<tab>E内のe_listの最初値の出現をカウントした整数が2のとき、<EOS>
<SOS>print("yes")<tab>"yes"を出力する<EOS>
<SOS>N, A, B, C, D  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にN、A、B、C、Dとする<EOS>
<SOS>a = N // A<tab>NをAで割った商をaとする<EOS>
<SOS>c = N // C<tab>NをCで割った商をcとする<EOS>
<SOS>if a * A < N  :<tab>aにAを掛けた値がNより小さいとき、<EOS>
<SOS>if c * C < N  :<tab>cにCを掛けた値がNより小さいとき、<EOS>
<SOS>b = a * B<tab>aにBを掛けた値をbとする<EOS>
<SOS>d = c * D<tab>cにDを掛けた値をdとする<EOS>
<SOS>if b < d  :<tab>bがdより小さいとき、<EOS>
<SOS>print(b)<tab>bを出力する<EOS>
<SOS>for i  in range(1000)  :<tab>'0から1000未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print("Hello World")<tab>"Hello World"を出力する<EOS>
<SOS>dic = {1 : 6000, 2 : 4000, 3 : 3000, 4 : 2000}<tab>((1, 6000)、(2, 4000)、(3, 3000)、(4, 2000))からなる辞書をdicとする<EOS>
<SOS>for i  in range(4)  :<tab>'0から4未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>t, n  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にtとnとする<EOS>
<SOS>print(dic[t] * n)<tab>dic(t)にnを掛けた値を出力する<EOS>
<SOS>for i  in range(7)  :<tab>'0から7未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>a, b  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にaとbとする<EOS>
<SOS>print(a - b)<tab>aからbを引いた値を出力する<EOS>
<SOS>for i  in range(9)  :<tab>'0から9未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>e, a, b  = map(str, input().split())<tab>map(str,入力された文字列を空白で分割した列)を展開し順にe、a、bとする<EOS>
<SOS>a = int(a)<tab>aの整数値をaとする<EOS>
<SOS>b = int(b)<tab>bの整数値をbとする<EOS>
<SOS>print(e, a + b, a * 200 + b * 300)<tab>e、aにbを加えた値、{{aに200を掛けた値}}に{{bに300を掛けた値}}を加えた値を出力する<EOS>
<SOS>s = 0<tab>0をsとする<EOS>
<SOS>for i  in range(10)  :<tab>'0から10未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print(s)<tab>sを出力する<EOS>
<SOS>i = 0<tab>0をiとする<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>x = int(input())<tab>入力された文字列の整数値をxとする<EOS>
<SOS>if x == 0  :<tab>xが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>x, y  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にxとyとする<EOS>
<SOS>if x == 0 and y == 0  :<tab>xが0、かつyが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>N = int(input())<tab>入力された文字列の整数値をNとする<EOS>
<SOS>for i  in range(N)  :<tab>'0からN未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>a, b, c  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にa、b、cとする<EOS>
<SOS>L = [a, b, c]<tab>(a、b、c)からなる列をLとする<EOS>
<SOS>m = L.pop(L.index(max(L)))<tab>L.pop(L.index(max(L)))をmとする<EOS>
<SOS>s = L[0] ** 2 + L[1] ** 2<tab>L(0)の2乗にL(1)の2乗を加えた値をsとする<EOS>
<SOS>if m ** 2 == s  :<tab>mの2乗がsのとき、<EOS>
<SOS>print("YES")<tab>"YES"を出力する<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>s = 100000<tab>100000をsとする<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>m = s % 1000<tab>sを1000で割った余りをmとする<EOS>
<SOS>if m != 0  :<tab>mが0と等しくないとき、<EOS>
<SOS>s = s - m + 1000<tab>sからmを引いた値に1000を加えた値をsとする<EOS>
<SOS>print(int(s))<tab>sの整数値を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>s = 0<tab>0をsとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>print(s)<tab>sを出力する<EOS>
<SOS>a, b, c  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にa、b、cとする<EOS>
<SOS>s = 0<tab>0をsとする<EOS>
<SOS>for i  in range(a, b + 1)  :<tab>'aからbに1を加えた値未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if c % i == 0  :<tab>cをiで割った余りが0のとき、<EOS>
<SOS>print(s)<tab>sを出力する<EOS>
<SOS>for i  in range(1, 10)  :<tab>'1から10未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>for j  in range(1, 10)  :<tab>'1から10未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>print(i, "x", j, "=", i * j, sep = "")<tab>i、"x"、j、"="、iにjを掛けた値、((sep, ""))からなる辞書を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>H,W = map(int,input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にHとWとする<EOS>
<SOS>if H==0 and W==0 :<tab>Hが0、かつWが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>for i  in range(H) :<tab>'0からH未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>for j  in range(W) :<tab>'0からW未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>print("#",end="")<tab>"#"と((end, ""))からなる辞書を出力する<EOS>
<SOS>print()<tab>空行を出力する<EOS>
<SOS>print()<tab>空行を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>H, W  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にHとWとする<EOS>
<SOS>if H == 0  :<tab>Hが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>H, W  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にHとWとする<EOS>
<SOS>if H == 0  :<tab>Hが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>a, op, b  = map(str, input().split())<tab>map(str,入力された文字列を空白で分割した列)を展開し順にa、op、bとする<EOS>
<SOS>a = int(a)<tab>aの整数値をaとする<EOS>
<SOS>b = int(b)<tab>bの整数値をbとする<EOS>
<SOS>if op == "?"  :<tab>opが"?"のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>A = [int(a) for a in input().split()]<tab>{{入力された文字列を空白で分割した列}}の各要素をaとし、aの整数値の列をAとする<EOS>
<SOS>print(min(A), max(A), sum(A))<tab>Aの最小値、Aの最大値、Aの総和を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>P = []<tab>空列をPとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>A = [int(a) for a in input().split()]<tab>{{入力された文字列を空白で分割した列}}の各要素をaとし、aの整数値の列をAとする<EOS>
<SOS>for i  in range(n - 1, -1, -1)  :<tab>'nから1を引いた値から-1未満までの-1間隔の数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if i == 0  :<tab>iが0のとき、<EOS>
<SOS>print(A[i])<tab>A(i)を出力する<EOS>
<SOS>s = 0<tab>0をsとする<EOS>
<SOS>for i  in range(5)  :<tab>'0から5未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>p = int(input())<tab>入力された文字列の整数値をpとする<EOS>
<SOS>if p < 40  :<tab>pが40より小さいとき、<EOS>
<SOS>print(s // 5)<tab>sを5で割った商を出力する<EOS>
<SOS>Si = []<tab>空列をSiとする<EOS>
<SOS>So = []<tab>空列をSoとする<EOS>
<SOS>for i  in range(4)  :<tab>'0から4未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>p = int(input())<tab>入力された文字列の整数値をpとする<EOS>
<SOS>Si.append(p)<tab>Si.append(p)<EOS>
<SOS>for j  in range(2)  :<tab>'0から2未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>p = int(input())<tab>入力された文字列の整数値をpとする<EOS>
<SOS>So.append(p)<tab>So.append(p)<EOS>
<SOS>s = sum(Si) - min(Si) + sum(So) - min(So)<tab>{{Siの総和からSiの最小値を引いた値}}にSoの総和を加えた値からSoの最小値を引いた値をsとする<EOS>
<SOS>print(s)<tab>sを出力する<EOS>
<SOS>W = []<tab>空列をWとする<EOS>
<SOS>K = []<tab>空列をKとする<EOS>
<SOS>for i  in range(10)  :<tab>'0から10未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>W.append(int(input()))<tab>W.append(int(input()))<EOS>
<SOS>for j  in range(10)  :<tab>'0から10未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>K.append(int(input()))<tab>K.append(int(input()))<EOS>
<SOS>Ws = sorted(W, reverse = True)<tab>Wと((reverse, 真))からなる辞書をソートした列をWsとする<EOS>
<SOS>Ks = sorted(K, reverse = True)<tab>Kと((reverse, 真))からなる辞書をソートした列をKsとする<EOS>
<SOS>w = 0<tab>0をwとする<EOS>
<SOS>k = 0<tab>0をkとする<EOS>
<SOS>for i  in range(3)  :<tab>'0から3未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print(w, k)<tab>wとkを出力する<EOS>
<SOS>A = [i for i in range(1, 31)]<tab>{{'1から31未満までの数列}}の各要素をiとし、iの列をAとする<EOS>
<SOS>N = []<tab>空列をNとする<EOS>
<SOS>for i  in range(28)  :<tab>'0から28未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>N.append(n)<tab>N.append(n)<EOS>
<SOS>R = list(set(A) - set(N))<tab>'Aの集合からNの集合を引いた値のリストをRとする<EOS>
<SOS>print(min(R))<tab>Rの最小値を出力する<EOS>
<SOS>print(max(R))<tab>Rの最大値を出力する<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>X = [int(x) for x in input().split()]<tab>{{入力された文字列を空白で分割した列}}の各要素をxとし、xの整数値の列をXとする<EOS>
<SOS>sub = max(X) - min(X)<tab>Xの最大値からXの最小値を引いた値をsubとする<EOS>
<SOS>if sub % 2 == 0  :<tab>subを2で割った余りが0のとき、<EOS>
<SOS>print(sub // 2)<tab>subを2で割った商を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n, k  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にnとkとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>M = []<tab>空列をMとする<EOS>
<SOS>for i  in range(10)  :<tab>'0から10未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>M.append(int(input()))<tab>M.append(int(input()))<EOS>
<SOS>Ms = sorted(M, reverse = True)<tab>Mと((reverse, 真))からなる辞書をソートした列をMsとする<EOS>
<SOS>for j  in range(3)  :<tab>'0から3未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>print(Ms[j])<tab>Ms(j)を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>print(input().upper())<tab>入力された文字列を英大文字に変換した文字列を出力する<EOS>
<SOS>print(input().swapcase())<tab>入力された文字列の英大文字を英小文字、英小文字を英大文字に変換した文字列を出力する<EOS>
<SOS>a = "abcdefghijklmnopqrstuvwxyz"<tab>"abcdefghijklmnopqrstuvwxyz"をaとする<EOS>
<SOS>A = [0 for i in range(26)]<tab>{{'0から26未満までの数列}}の各要素をiとし、0の列をAとする<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>for j  in range(26)  :<tab>'0から26未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>print(a[j], ":", A[j])<tab>a(j)、":"、A(j)を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n = input()<tab>入力された文字列をnとする<EOS>
<SOS>if n == "0"  :<tab>nが"0"のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>n = input()<tab>入力された文字列をnとする<EOS>
<SOS>KUPC = ["K", "U", "P", "C"]<tab>("K"、"U"、"P"、"C")からなる列をKUPCとする<EOS>
<SOS>kupc = [0 for i in range(4)]<tab>{{'0から4未満までの数列}}の各要素をiとし、0の列をkupcとする<EOS>
<SOS>for i  in range(len(n))  :<tab>'0からnの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if n[i] in KUPC  :<tab>n(i)がKUPCに含まれるとき、<EOS>
<SOS>print(min(kupc))<tab>kupcの最小値を出力する<EOS>
<SOS>W = input()<tab>入力された文字列をWとする<EOS>
<SOS>cnt = 0<tab>0をcntとする<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>t = input()<tab>入力された文字列をtとする<EOS>
<SOS>if t == "END_OF_TEXT"  :<tab>tが"END_OF_TEXT"のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>print(cnt)<tab>cntを出力する<EOS>
<SOS>s = input()<tab>入力された文字列をsとする<EOS>
<SOS>p = input()<tab>入力された文字列をpとする<EOS>
<SOS>S = s * 2<tab>sに2を掛けた値をSとする<EOS>
<SOS>if p in S  :<tab>pがSに含まれるとき、<EOS>
<SOS>print("Yes")<tab>"Yes"を出力する<EOS>
<SOS>T = input()<tab>入力された文字列をTとする<EOS>
<SOS>P = input()<tab>入力された文字列をPとする<EOS>
<SOS>l = len(P)<tab>Pの長さをlとする<EOS>
<SOS>for i  in range(len(T) - l + 1)  :<tab>'0から{{Tの長さからlを引いた値}}に1を加えた値未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if T[i : i + l] == P  :<tab>Tの位置iから位置{{iにlを加えた値}}までの部分がPのとき、<EOS>
<SOS>print(i)<tab>iを出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>C = input()<tab>入力された文字列をCとする<EOS>
<SOS>if C == "-"  :<tab>Cが"-"のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>t = 0<tab>0をtとする<EOS>
<SOS>h = 0<tab>0をhとする<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>T, H  = map(str, input().split())<tab>map(str,入力された文字列を空白で分割した列)を展開し順にTとHとする<EOS>
<SOS>if T > H  :<tab>TがHより大きいとき、<EOS>
<SOS>elif T < H  :<tab>('TがHより小さい',)<EOS>
<SOS>print(t, h)<tab>tとhを出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>d1 = input()<tab>入力された文字列をd1とする<EOS>
<SOS>if d1 == "0"  :<tab>d1が"0"のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>m, f, r  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にm、f、rとする<EOS>
<SOS>if m == -1 and f == -1 and r == -1  :<tab>{{mが-1}}、かつ{{fが-1かどうか}}、かつrが-1のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n, x  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にnとxとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>S = [i for i in range(1, 14)]<tab>{{'1から14未満までの数列}}の各要素をiとし、iの列をSとする<EOS>
<SOS>H = [i for i in range(1, 14)]<tab>{{'1から14未満までの数列}}の各要素をiとし、iの列をHとする<EOS>
<SOS>C = [i for i in range(1, 14)]<tab>{{'1から14未満までの数列}}の各要素をiとし、iの列をCとする<EOS>
<SOS>D = [i for i in range(1, 14)]<tab>{{'1から14未満までの数列}}の各要素をiとし、iの列をDとする<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>m, r  = map(str, input().split())<tab>map(str,入力された文字列を空白で分割した列)を展開し順にmとrとする<EOS>
<SOS>if m == "S"  :<tab>mが"S"のとき、<EOS>
<SOS>S.remove(int(r))<tab>Sからrの整数値を取り除いた集まり<EOS>
<SOS>elif m == "H"  :<tab>('mが"H"の',)<EOS>
<SOS>H.remove(int(r))<tab>Hからrの整数値を取り除いた集まり<EOS>
<SOS>elif m == "C"  :<tab>('mが"C"の',)<EOS>
<SOS>C.remove(int(r))<tab>Cからrの整数値を取り除いた集まり<EOS>
<SOS>if len(S) > 0  :<tab>Sの長さが0より大きいとき、<EOS>
<SOS>for i  in range(len(S))  :<tab>'0からSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print("S", S[i])<tab>"S"とS(i)を出力する<EOS>
<SOS>if len(H) > 0  :<tab>Hの長さが0より大きいとき、<EOS>
<SOS>for i  in range(len(H))  :<tab>'0からHの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print("H", H[i])<tab>"H"とH(i)を出力する<EOS>
<SOS>if len(C) > 0  :<tab>Cの長さが0より大きいとき、<EOS>
<SOS>for i  in range(len(C))  :<tab>'0からCの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print("C", C[i])<tab>"C"とC(i)を出力する<EOS>
<SOS>if len(D) > 0  :<tab>Dの長さが0より大きいとき、<EOS>
<SOS>for i  in range(len(D))  :<tab>'0からDの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print("D", D[i])<tab>"D"とD(i)を出力する<EOS>
<SOS>n, m  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にnとmとする<EOS>
<SOS>A = []<tab>空列をAとする<EOS>
<SOS>B = []<tab>空列をBとする<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>A.append([int(a) for a in input().split()])<tab>A.append([int(a) for a in input().split()])<EOS>
<SOS>for j  in range(m)  :<tab>'0からm未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>B.append(int(input()))<tab>B.append(int(input()))<EOS>
<SOS>C = []<tab>空列をCとする<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>c = 0<tab>0をcとする<EOS>
<SOS>for j  in range(m)  :<tab>'0からm未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>C.append(c)<tab>C.append(c)<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>print(C[i])<tab>C(i)を出力する<EOS>
<SOS>n, m, l  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にn、m、lとする<EOS>
<SOS>A = []<tab>空列をAとする<EOS>
<SOS>B = []<tab>空列をBとする<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>A.append([int(a) for a in input().split()])<tab>A.append([int(a) for a in input().split()])<EOS>
<SOS>for j  in range(m)  :<tab>'0からm未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>B.append([int(b) for b in input().split()])<tab>B.append([int(b) for b in input().split()])<EOS>
<SOS>C = []<tab>空列をCとする<EOS>
<SOS>L = []<tab>空列をLとする<EOS>
<SOS>s = 0<tab>0をsとする<EOS>
<SOS>for i  in range(l)  :<tab>'0からl未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>for j  in range(n)  :<tab>'0からn未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>for k  in range(m)  :<tab>'0からm未満までの数列の各要素を順にkとして、繰り返す<EOS>
<SOS>L.append(s)<tab>L.append(s)<EOS>
<SOS>s = 0<tab>0をsとする<EOS>
<SOS>C.append(L[i * n : i * n + n])<tab>C.append(L[i * n : i * n + n])<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>for j  in range(l)  :<tab>'0からl未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>if j == l - 1  :<tab>jがlから1を引いた値のとき、<EOS>
<SOS>print(C[j][i])<tab>C(j)(i)を出力する<EOS>
<SOS>r, c  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にrとcとする<EOS>
<SOS>A = []<tab>空列をAとする<EOS>
<SOS>for i  in range(r)  :<tab>'0からr未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>A.append([int(a) for a in input().split()])<tab>A.append([int(a) for a in input().split()])<EOS>
<SOS>A[i].append(sum(A[i]))<tab>A[i].append(sum(A[i]))<EOS>
<SOS>S = []<tab>空列をSとする<EOS>
<SOS>for i  in range(c + 1)  :<tab>'0からcに1を加えた値未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>s = 0<tab>0をsとする<EOS>
<SOS>for j  in range(r)  :<tab>'0からr未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>S.append(s)<tab>S.append(s)<EOS>
<SOS>A.append(S)<tab>A.append(S)<EOS>
<SOS>for i  in range(r + 1)  :<tab>'0からrに1を加えた値未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>for j  in range(c + 1)  :<tab>'0からcに1を加えた値未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>if j == c  :<tab>jがcのとき、<EOS>
<SOS>print(A[i][j])<tab>A(i)(j)を出力する<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>nn = n<tab>nをnnとする<EOS>
<SOS>N = []<tab>空列をNとする<EOS>
<SOS>print(n, ":", sep = "", end = " ")<tab>n、":"、((sep, "")と(end, " "))からなる辞書を出力する<EOS>
<SOS>if n % 2 == 0  :<tab>nを2で割った余りが0のとき、<EOS>
<SOS>while n % 2 == 0  :<tab>nを2で割った余りが0の間、繰り返す<EOS>
<SOS>N.append(2)<tab>N.append(2)<EOS>
<SOS>for i  in range(3, int(nn ** (1 / 2)) + 1, 2)  :<tab>'3からnnの(1 / 2)の組乗の整数値に1を加えた値未満までの2間隔の数列の各要素を順にiとして、繰り返す<EOS>
<SOS>while n % i == 0  :<tab>nをiで割った余りが0の間、繰り返す<EOS>
<SOS>N.append(i)<tab>N.append(i)<EOS>
<SOS>if n != 1  :<tab>nが1と等しくないとき、<EOS>
<SOS>N.append(n)<tab>N.append(n)<EOS>
<SOS>if len(N) == 0  :<tab>Nの長さが0のとき、<EOS>
<SOS>print(n)<tab>nを出力する<EOS>
<SOS>m, n  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にmとnとする<EOS>
<SOS>mod = 1000000007<tab>1000000007をmodとする<EOS>
<SOS>print(pow(m, n, mod))<tab>mのn乗に対するmodの剰余を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>a, b  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にaとbとする<EOS>
<SOS>if a == 0  :<tab>aが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>import math<tab>mathモジュールを用いる<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>A = [int(a) for a in input().split()]<tab>{{入力された文字列を空白で分割した列}}の各要素をaとし、aの整数値の列をAとする<EOS>
<SOS>ans = A[0]<tab>Aの最初値をansとする<EOS>
<SOS>for i  in range(1, n)  :<tab>'1からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>ans = ans * A[i] // math.gcd(ans, A[i])<tab>ansにA(i)を掛けた値をmath.gcd(ans, A[i])で割った商をansとする<EOS>
<SOS>print(ans)<tab>ansを出力する<EOS>
<SOS>import math<tab>mathモジュールを用いる<EOS>
<SOS>x, y  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にxとyとする<EOS>
<SOS>print(math.gcd(x, y))<tab>math.gcd(x, y)を出力する<EOS>
<SOS>import math<tab>mathモジュールを用いる<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>cnt = 0<tab>0をcntとする<EOS>
<SOS>for i  in range(2, int(math.sqrt(a)) + 1)  :<tab>'2からmath.sqrt(a)の整数値に1を加えた値未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if a % i == 0  :<tab>aをiで割った余りが0のとき、<EOS>
<SOS>return False<tab>偽を関数出力とする<EOS>
<SOS>return True<tab>真を関数出力とする<EOS>
<SOS>for i  in range(n)  :<tab>'0からn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if prime(int(input()))  :<tab>prime(入力された文字列の整数値)のとき、<EOS>
<SOS>print(cnt)<tab>cntを出力する<EOS>
<SOS>import re<tab>reモジュールを用いる<EOS>
<SOS>I = input().split()<tab>入力された文字列を空白で分割した列をIとする<EOS>
<SOS>S = []<tab>空列をSとする<EOS>
<SOS>for i  in range(len(I))  :<tab>'0からIの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>I[i]  = re.split("[,.]", I[i])<tab>文字列I(i)を正規表現"[,.]"で分割した文字列リストをI[i] にする<EOS>
<SOS>if 2 < len(I[i][0]) and len(I[i][0]) < 7  :<tab>2がI(i)の最初値の長さより小さく、かつI(i)の最初値の長さが7より小さいとき、<EOS>
<SOS>S.append(I[i][0])<tab>S.append(I[i][0])<EOS>
<SOS>for i  in range(len(S))  :<tab>'0からSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if i == len(S) - 1  :<tab>iがSの長さから1を引いた値のとき、<EOS>
<SOS>print(S[i])<tab>S(i)を出力する<EOS>
<SOS>S = input()<tab>入力された文字列をSとする<EOS>
<SOS>cnt = -1<tab>-1をcntとする<EOS>
<SOS>for i  in range(len(S))  :<tab>'0からSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if i == len(S) - 1  :<tab>iがSの長さから1を引いた値のとき、<EOS>
<SOS>print(S[0])<tab>Sの最初値を出力する<EOS>
<SOS>A = [chr(i) for i in range(65, 65 + 26)]<tab>{{'65から{{65に26を加えた値}}未満までの数列}}の各要素をiとし、文字コードiの文字の列をAとする<EOS>
<SOS>D = [chr(i) for i in range(68, 68 + 23)]<tab>{{'68から{{68に23を加えた値}}未満までの数列}}の各要素をiとし、文字コードiの文字の列をDとする<EOS>
<SOS>D.append("A")<tab>D.append("A")<EOS>
<SOS>D.append("B")<tab>D.append("B")<EOS>
<SOS>D.append("C")<tab>D.append("C")<EOS>
<SOS>n = input()<tab>入力された文字列をnとする<EOS>
<SOS>ANS = []<tab>空列をANSとする<EOS>
<SOS>for i  in range(len(n))  :<tab>'0からnの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>ANS.append(A[D.index(n[i])])<tab>ANS.append(A[D.index(n[i])])<EOS>
<SOS>for i  in range(len(ANS))  :<tab>'0からANSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if i == len(ANS) - 1  :<tab>iがANSの長さから1を引いた値のとき、<EOS>
<SOS>print(ANS[i])<tab>ANS(i)を出力する<EOS>
<SOS>S = input().split()<tab>入力された文字列を空白で分割した列をSとする<EOS>
<SOS>l = 0<tab>0をlとする<EOS>
<SOS>n = 0<tab>0をnとする<EOS>
<SOS>L = "a"<tab>"a"をLとする<EOS>
<SOS>N = "a"<tab>"a"をNとする<EOS>
<SOS>for i  in range(len(S))  :<tab>'0からSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if S.count(S[i]) > n  :<tab>S内のS(i)の出現をカウントした整数がnより大きいとき、<EOS>
<SOS>n = S.count(S[i])<tab>S内のS(i)の出現をカウントした整数をnとする<EOS>
<SOS>N = S[i]<tab>S(i)をNとする<EOS>
<SOS>for i  in range(len(S))  :<tab>'0からSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if len(S[i]) > l  :<tab>S(i)の長さがlより大きいとき、<EOS>
<SOS>l = len(S[i])<tab>S(i)の長さをlとする<EOS>
<SOS>L = S[i]<tab>S(i)をLとする<EOS>
<SOS>print(N, L)<tab>NとLを出力する<EOS>
<SOS>s = input()<tab>入力された文字列をsとする<EOS>
<SOS>S = []<tab>空列をSとする<EOS>
<SOS>a = "apple"<tab>"apple"をaとする<EOS>
<SOS>p = "peach"<tab>"peach"をpとする<EOS>
<SOS>A = []<tab>空列をAとする<EOS>
<SOS>P = []<tab>空列をPとする<EOS>
<SOS>for i  in range(len(s))  :<tab>'0からsの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>S.append(s[i])<tab>S.append(s[i])<EOS>
<SOS>for i  in range(5)  :<tab>'0から5未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>A.append(a[i])<tab>A.append(a[i])<EOS>
<SOS>P.append(p[i])<tab>P.append(p[i])<EOS>
<SOS>for i  in range(len(S))  :<tab>'0からSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if S[i : i + 5] == A  :<tab>Sの位置iから位置{{iに5を加えた値}}までの部分がAのとき、<EOS>
<SOS>S[i : i + 5]  = P<tab>PをS[i : i + 5] にする<EOS>
<SOS>elif S[i : i + 5] == P  :<tab>('Sの位置iから位置{{iに5を加えた値}}までの部分がPの',)<EOS>
<SOS>S[i : i + 5]  = A<tab>AをS[i : i + 5] にする<EOS>
<SOS>for i  in range(len(S))  :<tab>'0からSの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if i == len(S) - 1  :<tab>iがSの長さから1を引いた値のとき、<EOS>
<SOS>print(S[i])<tab>S(i)を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>x, y, s  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にx、y、sとする<EOS>
<SOS>if x == 0  :<tab>xが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n, m  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にnとmとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>import math<tab>mathモジュールを用いる<EOS>
<SOS>P = []<tab>空列をPとする<EOS>
<SOS>Max = 123456 * 2<tab>123456に2を掛けた値をMaxとする<EOS>
<SOS>D = list(range(2, Max))<tab>''2からMax未満までの数列のリストをDとする<EOS>
<SOS>limit = math.sqrt(Max)<tab>math.sqrt(Max)をlimitとする<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>p = D[0]<tab>Dの最初値をpとする<EOS>
<SOS>if limit <= p  :<tab>limitがp以下のとき、<EOS>
<SOS>return P<tab>Pを関数出力とする<EOS>
<SOS>P.append(p)<tab>P.append(p)<EOS>
<SOS>D = [d for d in D if d % p != 0]<tab>Dの各要素をdとし、{{{{dをpで割った余り}}が0と等しくない}}ときのdの列をDとする<EOS>
<SOS>e = Era(P, Max)<tab>Era(P,Max)をeとする<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>n = int(input())<tab>入力された文字列の整数値をnとする<EOS>
<SOS>if n == 0  :<tab>nが0のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>N, T, E  = map(int, input().split())<tab>map(整数,入力された文字列を空白で分割した列)を展開し順にN、T、Eとする<EOS>
<SOS>X = list(map(int, input().split()))<tab>'map(整数,{{入力された文字列を空白で分割した列}})のリストをXとする<EOS>
<SOS>time = [i for i in range(T - E, T + E + 1)]<tab>'{{TからEを引いた値}}から{{{{TにEを加えた値}}に1を加えた値}}未満までの数列の各要素をiとし、iの列をtimeとする<EOS>
<SOS>clock = -2<tab>-2をclockとする<EOS>
<SOS>for i  in range(len(X))  :<tab>'0からXの長さ未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>for j  in range(len(time))  :<tab>'0からtimeの長さ未満までの数列の各要素を順にjとして、繰り返す<EOS>
<SOS>if time[j] % X[i] == 0  :<tab>time(j)をX(i)で割った余りが0のとき、<EOS>
<SOS>clock = X.index(X[i])<tab>X.index(X[i])をclockとする<EOS>
<SOS>print(clock + 1)<tab>clockに1を加えた値を出力する<EOS>
<SOS>while True :<tab>真の間、繰り返す<EOS>
<SOS>hantei1 = hantei2=  hantei3 = 0<tab>0をhantei3をhantei2とするとするをhantei1とする<EOS>
<SOS>n = input()<tab>入力された文字列をnとする<EOS>
<SOS>if n == '.' :<tab>nが'.'のとき、<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>l_n = list(n)<tab>'nのリストをl_nとする<EOS>
<SOS>lenn = len(l_n)<tab>l_nの長さをlennとする<EOS>
<SOS>kakko = []<tab>空列をkakkoとする<EOS>
<SOS>lenkakko = len(kakko)<tab>kakkoの長さをlenkakkoとする<EOS>
<SOS>for i  in range(lenn) :<tab>'0からlenn未満までの数列の各要素を順にiとして、繰り返す<EOS>
<SOS>if l_n.count('(') != l_n.count(')') or l_n.count('[') != l_n.count(']') :<tab>{{l_n内の'('の出現をカウントした整数}}が{{l_n内の')'の出現をカウントした整数}}と等しくなく、または{{l_n内の'['の出現をカウントした整数}}が{{l_n内の']'の出現をカウントした整数}}と等しくないとき、<EOS>
<SOS>print('no')<tab>'no'を出力する<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>if l_n[i] == '(' :<tab>l_n(i)が'('のとき、<EOS>
<SOS>kakko.append('maru')<tab>kakko.append('maru')<EOS>
<SOS>if l_n[i] == '[' :<tab>l_n(i)が'['のとき、<EOS>
<SOS>kakko.append('shikaku')<tab>kakko.append('shikaku')<EOS>
<SOS>if len(kakko) != 0 :<tab>kakkoの長さが0と等しくないとき、<EOS>
<SOS>if kakko[-1] == 'maru' :<tab>kakko(-1)が'maru'のとき、<EOS>
<SOS>if l_n[i] == ']' :<tab>l_n(i)が']'のとき、<EOS>
<SOS>print('no')<tab>'no'を出力する<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>if kakko[-1] == 'shikaku' :<tab>kakko(-1)が'shikaku'のとき、<EOS>
<SOS>if l_n[i] == ')' :<tab>l_n(i)が')'のとき、<EOS>
<SOS>print('no')<tab>'no'を出力する<EOS>
<SOS>break<tab>繰り返すのを中断する<EOS>
<SOS>if l_n[i] == ')' or l_n[i] == ']' :<tab>l_n(i)が')'、またはl_n(i)が']'のとき、<EOS>
<SOS>kakko.pop(-1)<tab>kakko.pop(-1)<EOS>
<SOS>if hantei1 == 0 :<tab>hantei1が0のとき、<EOS>
<SOS>print('yes')<tab>'yes'を出力する<EOS>
