print ( A + ( 31 - B ) * 50 )
return - A <= B and B <= A
for A in range ( B [ C ] , D , E [ C ] ) :
A = 0 if B == '+' else 1
return False
unite ( A * 12 + B , C * 12 + D )
print ( 1 if topological_sort ( A , B ) else 0 )
if EQ ( A [ B ] . imag , 4 ) and EQ ( A [ C ] . imag , 4 ) :
A [ 1 ] = [ 0 ] * B
for A in range ( B - 1 , 0 , - 1 ) :
A , B = C [ 0 ] , B - C [ 0 ]
A [ B ] = A [ B + 1 ] = C
A = complex ( B [ 2 ] , B [ 3 ] )
A = B + C + ( B * D ) // 100 + ( C * D ) // 100
A , B = list ( map ( int , input ( ) . split ( ) ) )
A = 1
if A . find ( B ) >= 0 :
A >>= 1
A = bisect_left ( B , B [ C ] - B [ D ] ) - 1
A [ B ] = int ( input ( ) )
if A == 2 and B == 2 :
A += [ B + ( C << 18 ) for C in range ( D ) ]
for A in range ( 0 , 10 ) :
A . ws [ B ] = C
print ( 'Data ' , A + 1 , ':' , sep = '' )
A = [ 0 ] * 10
check ( A , B [ C ] [ 1 ] )
A = A . replace ( 'apple' , '_____' )
A = [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ]
A , B , C , D = list ( map ( int , input ( ) . split ( ) ) )
for A in D [ B [ C ] ] :
A [ B ] [ C ] |= 4
A = False
if A [ B ] <= A [ C [ D - 1 ] ] :
A = ( B + C ) / 2
A , B = [ ] , [ ]
A . append ( A [ 0 ] )
A = B [ input ( ) . strip ( ) ]
A += B * C
if A [ B ] [ C ] [ D ] < E :
A . sort ( key = lambda x : ( - B [ 0 ] , B [ 1 ] ) )
A += 12
A , B = calc ( )
print ( A , B , C , D )
for A , B in C [ : : - 1 ] :
A = [ B ] * 2
A = B [ C - 1 ]
A , B = list ( map ( int , C . split ( ) ) )
if prev_permutation ( A ) :
print ( * sorted ( list ( set ( A ) ) ) )
A = bisect_left ( B , C , 0 , D )
if A . par [ B ] < 0 :
A = [ [ [ B for C in range ( D + 1 ) ] for E in range ( D + 1 ) ] for F in range ( G + 1 ) ]
A , B = 0 , True
A [ B ] [ C ] = A [ D ] [ C ]
print ( * [ A // B for A in C ] )
B = ( A - 61 ) // 20 + 1
if A < 5 :
A = [ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] , [ 0 , 2 , 6 , 3 , 4 , 1 , 5 ] , [ 0 , 4 , 2 , 1 , 6 , 5 , 3 ] , [ 0 , 3 , 2 , 6 , 1 , 5 , 4 ] , [ 0 , 5 , 1 , 3 , 4 , 6 , 2 ] ]
C = 0
A , B = C . popleft ( )
print ( math . factorial ( int ( input ( ) ) ) )
A = { 0 : 'IDENTICAL' , 1 : 'CLOSE' , 2 : 'DIFFERENT' }
B = A
A = 2 if B > C else - 2
A = dijkstra ( B , C , D )
A , B = 0 , 31
rec ( 0 , 0 )
A [ B ] [ 2 * C - 1 - D - B ] = E
B [ C ] = 1
A *= 3
A . append ( complex ( B , C ) )
A = max ( - B [ C - D ] , E [ C - D ] )
A = B = C
A , B , C = 0 , - 1 , 0
while A < len ( B ) and B [ A ] == ']' :
A [ 1 ] = 0
A [ chr ( ord ( 'A' ) + B ) ] = C
rec ( A + 1 , B - C , C )
A = 10 ** len ( B )
print ( ( A [ B ] * C [ B ] ) / C [ 0 ] )
A = B * C - ( C * ( C + 1 ) ) // 2
A , B = [ 0 ] * 202 , [ 0 ] * 202
insort_left ( A , B )
if A [ B ] [ C - 1 ] < D :
if A [ B ] == C [ D ] :
if A & 1 == 0 :
A = max ( A , B - C )
B -= 1
A , B = C . find ( A ) , C . find ( B )
if A != 0 and B != 0 and C != 0 :
if A == 'R' :
A , B , C = [ ] , set ( ) , set ( )
if A [ B ] >= 'a' and A [ B ] <= 'z' :
if A [ B ] [ C ] > D :
print ( 1 + A * ( A + 1 ) // 2 )
print ( A - 2 * B )
A = B . replace ( 'X' , str ( C ) )
A = [ [ ] for B in range ( 8 ) ]
A += str ( B )
A += 60 * B [ C ] + B [ C + 1 ]
A , B = 0 , 0
A [ B ] [ C ] [ D ] [ E ] += A [ B ] [ C - 1 ] [ D ] [ D ]
A += B * C + D
print ( A , '{:d}.{:02d}' . format ( B // 100 , B % 100 ) )
A , B , C = [ ] , [ ] , { }
A [ B + C ] [ 1 ] = 17 * ( D & 1 ) + 3 * ( D % 3 ) + 19
A . iter = [ 0 ] * B
A , B , C , D = map ( float , input ( ) . split ( ) )
print ( min ( A ) , max ( A ) )
A = list ( map ( int , input ( ) . split ( ) ) ) + [ - 1 ]
for A , B , C in D :
for A in range ( 5 - len ( B ) ) :
if A [ B ] == '[' :
while len ( A ) :
A , B = map ( int , C . split ( ) )
print ( len ( A ) )
if A == 1 or B == 1 :
A += ')'
setcontext ( Context ( prec = A , rounding = B ) )
A [ B + 1 ] [ C + 1 ] = min ( A [ B + 1 ] [ C + 1 ] , A [ B ] [ C ] + D [ B ] * E [ C ] )
A . size [ B ] += A . size [ C ]
if A == 'X' :
A [ B ] [ C ] = D
if A . par [ B ] < A . par [ C ] :
A [ B ] [ C ] [ D ] = E
A = 2 - ( B & 1 )
A [ B ] = A [ B - 1 ] + C
while A > 1 and cross ( B [ A - 1 ] - B [ A - 2 ] , C [ D ] - B [ A - 1 ] ) < 0 :
A -= 3 * B
if A <= B and C [ A ] == 0 :
A = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 }
A . append ( [ B , C , C - B ] )
A , B = C [ ord ( D [ E ] ) - F ] , G [ ord ( D [ E ] ) - F ]
A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) )
A , B = { } , [ ]
A . power [ B ] += C
for A in range ( 2 , B , 2 ) :
for A in range ( 0 , B , 2 ) :
A = B [ A ] [ int ( C ) ]
A = [ '' ] * 100
print ( * list ( str ( A [ B ] ) ) )
if A [ B ] > C [ D ] :
print ( A - 1 )
A = [ [ '' for B in range ( 5 ) ] for C in range ( 8 ) ]
A += ( B [ C ] . real - B [ C + 1 ] . real ) * ( B [ C ] . imag + B [ C + 1 ] . imag )
if A >= 1 :
for A in range ( int ( input ( ) ) ) :
A [ B ] [ 0 ] [ 0 ] = 0
A , B = list ( C . split ( '+' ) )
A = ( B * C ) // ( C + D )
A . sort ( key = lambda x : ( B [ 1 ] , B [ 0 ] ) )
A -= 2
if A [ B ] [ 2 ] < C :
for A in range ( B + 1 , 2 * C + 1 ) :
A [ B : ] = 1
B = C [ 0 ]
return A
for A in re . findall ( '[0-9]+' , B ) :
while A >= 0 and B [ A ] >= B [ A + 1 ] :
A = [ 0 , 1 , 0 , - 1 ]
return - 1 if A <= 0 else 1
A , B = C , 0
if re . match ( A , B ) :
if A [ B + 2 ] == '[' :
A , B = d2t ( C [ D ] ) , d2t ( C [ D + 1 ] )
A = [ [ 0 for B in range ( C + 2 ) ] for D in range ( 2 ) ]
print ( B [ A ] if A in B else 0 )
if len ( A ) > 1 and A [ 0 ] == '_' :
if ( A < B ) or ( A == B and C < D ) :
for A , B , C , D , E in F :
if len ( A ) == 4 and A in B :
A , B = C . pop ( ) , C . pop ( )
A , B = factor ( B + 1 )
A , B , C = 0 , 0 , 0
A [ B ] -= 1
[ A . append ( B ) for B in range ( 0 , C + 1 ) ]
A = 0.01745329251994329576923690768489
for A in range ( 0 , len ( B ) , 5 ) :
A , B = ( C - 1 ) // D + 1 , ( E - 1 ) // F + 1
if A < 10 and B [ C ] < 3 :
print ( 31 )
if A == B + 1 or A == B - 1 :
parse ( A , B [ C ] [ 0 ] )
A . heappush ( B , ( ( - C << D ) | E , E , C ) )
if A [ B ] [ C ] == 0 :
if A <= 1 :
if A + 1 < B and C [ D ] [ A ] == C [ D ] [ A + 1 ] :
if A [ 0 ] == '0' :
A [ B ] = 1
if A > B [ C ] :
return ( A + A // 4 - A // 100 + A // 400 + ( 13 * B + 8 ) // 5 + C ) % 7
A = [ 0 ] * 3
A [ B ] [ C ] , A [ C ] [ B ] = D , D
A , B = [ [ 0 for C in range ( 16 ) ] for D in range ( 20 ) ] , 0
A = dijkstra ( B , C , D , E , F )
if len ( set ( A ) ) == 1 :
if A > 20 :
if A [ B ] > A [ B + 1 ] :
A [ B ] [ C ] = A [ D ] [ E ] + F
A , B = map ( float , input ( ) . split ( ) )
A [ 1 ] = 1.0
if A [ B ] == 'Y' :
A = ( 1 , 5 , 10 , 50 , 100 , 500 )
print ( A if A <= 0 else A - ( B - C ) )
for A in range ( 1000 ) :
A = [ [ 0 for B in range ( 45 ) ] for C in range ( 45 ) ]
A , B , C = int ( A ) , int ( B ) , int ( C )
A . edge [ B ] . append ( [ C , D , E ] )
if A == B [ C - 1 ] :
A = [ [ 0.0 for B in range ( C ) ] for D in range ( E ) ]
A = 0x7ffffffffffffff
A = bisector ( B [ C ] , B [ D ] )
A = sorted ( B . items ( ) , key = lambda x : A [ 1 ] )
if A <= 3 :
if - A < B < A :
A [ B ] [ C ] [ 7 - D ] = A [ B - 1 ] [ D ] [ C ]
print ( len ( A & B ) )
A [ B ] += A [ C ]
A . extend ( A )
A , B = list ( input ( ) . split ( '=' ) )
A += B // 3
A = input ( )
A , B = A - 1 , B + 1
A = A * 2 - B * B
B = ( A - 1 ) // 5 + 1
A , B = ( 30 * C + ( D // 2 ) ) * 2 , ( 6 * D ) * 2
A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )
A = ( B ** 2 + C ** 2 ) ** 0.5
if calc ( A , B , C , D , 0 ) [ 0 ] == E :
A , B , C , D = E . split ( )
A = int ( input ( ) ) + int ( input ( ) )
A [ B ] [ C ] = max ( A [ B ] [ C ] , A [ B - 1 ] [ D ] * E [ D ] [ C ] )
A = 1 - A
for A in range ( 9 , - 1 , - 1 ) :
A . edge [ B ] [ C ] [ 1 ] -= D
for A in range ( 1001 - B ) :
A = bisect_right ( B , C [ 2 ] , D )
if A >= 0 and A < B and C >= 0 and C < B and D [ A ] [ C ] == E :
return True
A = len ( B [ 0 ] )
A = [ list ( input ( ) ) for B in range ( C ) ]
if A [ B ] < C and C <= A [ B + 1 ] :
A = B + ( C << 18 )
if A [ B ] - A [ B - 1 ] < C :
if A + 1 < B and C [ A ] [ D ] == C [ A + 1 ] [ D ] :
if A [ 0 ] != ',' :
import bisect
if A [ B ] < 0 :
A = bisect_right ( B , int ( C [ 2 ] ) , D )
A = [ int ( input ( ) ) for B in range ( 5 ) ]
A = int ( input ( ) ) * 2
A = [ 0 ] * 105
A -= B
print ( A - 1 - B )
if A < 0 and B < 0 :
if A < 0 or B == A :
print ( A [ B ] [ 0 ] )
A . items . append ( B )
A = 'D'
if A [ B - 1 ] [ C - 1 ] :
A = B [ C ] - D
A = [ [ 0 for B in range ( C + 2 ) ] for D in range ( C + 2 ) ]
A = B [ 0 ] [ 1 ]
if A [ B ] [ C ] <= 40 and ( ( 1730 <= D and D <= 1930 ) or ( 1730 <= E and E <= 1930 ) ) :
return A [ 0 ] + B * ( cross ( C , D [ 0 ] - A [ 0 ] ) / cross ( C , B ) )
A , B = 0 , [ 0 ] * 1002
print ( B if A == 0 else A )
A . append ( [ B , C , 0 , D ] )
A = { }
A = [ 0 ] * 6
A += B [ C ] - B [ D - 1 ] - 1
print ( A * B / 3.305785 )
A = B [ C ] [ 1 ] - 10080 if B [ C ] [ 1 ] >= 10080 else 0
if A in B :
A = [ B for B in range ( C + 1 ) ]
B = A . readline
A . append ( A [ - 1 ] + B - C )
A . append ( complex ( B [ 2 ] , B [ 3 ] ) )
for A in range ( 19 , - 1 , - 1 ) :
A . level = [ - 1 ] * A . V
A = [ [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] ]
print ( calc ( input ( ) ) )
A = [ 0 for B in range ( 30001 ) ]
for A in sorted ( B , key = lambda x : ( - C [ 2 ] , C [ 3 ] , C [ 1 ] ) ) :
A [ B ] = 2
if A [ B ] < 10 :
if A [ B ] > 0 :
A , B = C . heappop ( D )
A = ( B - C ) * ( B - C ) + ( D - E ) * ( D - E )
if A [ B - C - 1 ] > 0 :
A = A + C if B == '+' else A * C
A = format ( B , 'o' )
A . append ( complex ( B [ 0 ] , B [ 1 ] ) )
A [ B [ 0 ] ] . append ( B )
if A > 1000000 :
A , B , C , D = list ( input ( ) . split ( ) )
return A . items == [ ]
print ( A [ B >> 1 ] )
A [ B ] = C if A [ B - 1 ] + C < C else A [ B - 1 ] + C
A = B [ C ] [ 1 ] * D [ C ] + B [ C ] [ 2 ]
if A < 165 :
A , B = C [ D ] [ 0 ] , C [ D ] [ 1 ]
print ( A if A >= B else B )
A += B [ 1 - ( C & 1 ) ] [ 1 ]
if EQ ( A [ B ] . real , 0 ) :
A = nlcm ( B , C )
A = tuple ( map ( int , input ( ) . split ( ) ) )
rec ( 0 , 0 , 0 )
for A in range ( B . iter [ C ] , len ( B . edge [ C ] ) ) :
if A <= B and A <= C :
return math . hypot ( A . real - B . real , A . imag - B . imag )
A = math . sqrt ( B * B + C * C - 2 * B * C * math . cos ( D - math . fabs ( E ) ) )
A = ( ( 1 , 4 ) , ( 0 , 2 , 5 ) , ( 1 , 3 , 6 ) , ( 2 , 7 ) , ( 0 , 5 ) , ( 1 , 4 , 6 ) , ( 2 , 5 , 7 ) , ( 3 , 6 ) )
for A in range ( 1 , 11 ) :
A = set ( input ( ) . split ( ) )
if same ( A , B ) :
A [ B ] [ C + 1 ] |= 8
A = B = C = D = E = 0
A [ B [ 0 ] [ 0 ] ] = C = 1
print ( 'YES' if A >= 4 else 'NO' )
A , B , C = 1 , 1 , 0
if A > 0 and B . level [ C ] < B . level [ D ] :
if A < B [ C ] :
A . find ( B )
while A [ B - 1 ] != C :
A = [ [ B - 1 ] if B > 0 else [ [ ] for B in range ( C ) ] ]
A [ B ] = A [ B - 1 ] + math . atan ( 1 / C [ B - 1 ] )
A [ B ] . append ( ( C , D , E ) )
if ( A [ 1 ] | A [ 2 ] ) == 0 :
A = B [ C ] [ 1 ]
A , B = [ 0 ] * 27 , [ 0 ] * 27
A , B = root ( C ) , root ( D )
init ( 12 * 12 )
A [ int ( input ( ) ) ] += 1
A = B [ C ] [ D ]
return chr ( ( A * B + C ) % D + E )
A , B = C
A , B = C , - 1
A = 1e-7
for A in range ( B - 1 , - 1 , - 1 ) :
if A [ B : C ] != D [ E : F ] :
A = [ 0 ] * B
return A % 4 == 0 and ( A % 100 != 0 or A % 400 == 0 )
B [ A ] = 1
if A == B + 4 :
A , B = A - 1 , B - 1
print ( * [ ( '{}:{:02}' . format ( * A ) ) for A in sorted ( B ) ] )
print ( 'OK' if ( 2 * A ) ** 2 > B else 'NA' )
A , B = C [ 1 ] , C [ 2 ]
A = B * ( B - 1 ) >> 1
A += 7 * B
A = int ( input ( ) ) + 1
A [ 0 ] , A [ 1 ] = 2 , 3
A = 1
A = max ( A , B * ( C - 1 - D ) )
if A [ B ] [ C ] and D . root ( id ( B , C ) ) == id ( B , C ) :
A = [ [ ] for B in range ( 100 ) ]
A = [ ]
print ( 'Hello World' )
A [ B + 1 ] [ C + D ] += A [ B ] [ C ]
A . sort ( key = lambda x : ( - B [ 1 ] , B [ 0 ] ) )
A = crossPointLL ( B , C )
if A [ B ] or C > D [ E ] :
A [ B . index ( C ) ] += 1
if A [ B ] + C [ D ] < E :
for A in range ( B ** 2 , 300 ) :
import re
A , B = [ 0 ] * 31 , [ ]
A = list ( input ( ) )
A . append ( B [ C ] )
for A in range ( B - 1 , C - 2 , - 1 ) :
return 'A'
A = B * 60 + C
[ A . append ( B ) for B in range ( 5 , 0 , - 1 ) ]
A = [ [ ] for B in range ( C ) ]
A [ B + 1 ] [ C - 1 ] += 1
A = 3 + B // 4 - B // 100 + B // 400
A [ 1 ] [ B ] = 1
A += 'R'
A = gcd ( A , B [ C ] )
if A <= 160 and B <= 25 :
A = 1000 - int ( input ( ) )
A . ws [ B ] += A . ws [ A . par [ B ] ]
for A in range ( B - 1 , len ( C ) ) :
return 0
A = 1 + min ( B [ C - 1 ] [ D - 1 ] , B [ C ] [ D - 1 ] , B [ C - 1 ] [ D ] )
A [ 21 ] , A [ 22 ] , A [ 23 ] , A [ 24 ] , A [ 25 ] = 'f' , 'g' , 'h' , 'i' , 'j'
return abs ( A - B ) + abs ( C - D )
A = dot ( B [ 1 ] - B [ 0 ] , C [ 1 ] - C [ 0 ] )
A [ B + 1 ] = A [ B ] + ( C [ B ] == 'J' )
A >>= 2
A [ B [ C ] ] += 1
A = int ( A )
A . append ( ( int ( B [ 0 ] ) , int ( B [ 1 ] ) , B [ 2 ] , int ( B [ 3 ] ) , B [ 4 ] ) )
return [ A , B + 1 ]
A = ( B << 9 ) + ( C << 18 )
if A [ B - 1 ] [ C ] > D :
if A [ B - C ] > A [ C ] + D :
A [ B ] [ 1 ] -= 1
A , B , C , D , E = map ( int , input ( ) . split ( ) )
A , B = A - 1 , C - 1
A = B . imag - C . imag
A , B = [ 0 ] * C , [ 0 ] * C
while A :
print ( sum ( [ A * B ** 2 for B in range ( A , 600 , A ) ] ) )
A . bfs ( B )
if A == '=' :
for A in range ( B - C + 1 ) :
for A in range ( 3 , 11 ) :
A = B [ C + 1 ]
A , B , C , D = list ( map ( int , input ( ) . split ( ',' ) ) )
return [ True , A ]
if next_permutation ( A ) :
print ( 1 if A [ B ] == C else 0 )
if A [ B ] == '-' and C and A [ B + 1 ] >= '0' and A [ B + 1 ] <= '9' :
A = ( 1440 * B + C * 60 + D ) % 10080
A = D [ E ]
if A [ B ] == 1 :
if A >= 0 and B >= 0 :
A = - 1
A [ B ] = A [ C ] = A [ D ] = False
if A > 10 or B < C [ A ] or B > D [ A ] :
A = B - ( C . imag - D . imag ) * 100
A = B . find ( B . par [ C ] )
A = max ( B [ C ] - D , E - F [ C ] )
A = [ complex ( * map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ]
if A == B [ C ] :
if A [ B ] [ C ] != D :
if A < B [ C ] [ D ] [ E ] :
A , B , C , D = E . heappop ( F )
A = str ( B ** C ) [ : : - 1 ]
if A == '' :
return [ A , B ]
if A & ( 1 << B ) :
A = B [ : : - 1 ]
return factorial ( A ) // factorial ( A - B ) // factorial ( B )
A = 1000
A = [ 'lunch' , 'dinner' , 'midnight' ]
A , B = int ( A ) , int ( B )
A = [ input ( ) . strip ( ) for B in range ( C ) ]
A = [ 'pre-meiji' , 'meiji' , 'taisho' , 'showa' , 'heisei' ]
A = A + C * 60 if A >= B else A + ( C + 1 ) * 60
A = B [ C // 2 : ]
for A in B [ 1 : ] :
if A [ B ] == '=' :
A [ B ] [ C ] |= 2
A = cross ( B - C , D [ 0 ] - C )
A [ B ] += 1
if A [ B [ C ] ] == 1 :
if re :
A , B , C , D = 0 , True , 0 , 0
A [ B ] [ C - 1 - B ] = D
import math
A = 1e-5
A = [ 0 ] * ( B + max ( C , D ) + 1 )
B = int ( A )
A . append ( B + C )
A , B , C = D . pop ( )
A , B , C , D = list ( map ( float , input ( ) . split ( ) ) )
A , B = C * D , E
A = str ( int ( B [ C : C + 4 ] [ : : - 1 ] ) )
A = circumscribed_circle ( B , C , D )
if A [ 0 ] == 'E' :
print ( A [ 0 ] [ B + 1 ] - 1 )
print ( dijkstra ( A , B , C , D ) )
if A == 0 :
A = B % 10
A = [ B ] * ( C + 1 )
if A == 'A' :
A = [ [ 0 for B in range ( 2 ) ] for C in range ( D ) ]
A = [ [ 0 for B in range ( 3 ) ] for C in range ( D ) ]
A , B = C [ 0 ] - 1 , C [ 1 ]
A = WeightedUnionSet ( B + 1 )
if A == 'L' :
A = B << 1
A = max ( B [ C ] - D , E [ C ] - F )
if A [ B ] > A [ C ] :
A [ B ] . append ( ( C , D ) )
for A in range ( 2 , 18 ) :
A . unite ( B , C , D )
A , B , C = int ( 100 * A ) , int ( 100 * B ) , int ( 100 * C )
if A < 0 or A >= 3 or B < 0 or B >= 3 or 3 * A + B == C :
A [ B + 1 ] [ C ] += 1
print ( A [ 0 ] )
A = B | ( C << ( D * 3 ) ) | ( E << ( F - 1 ) * 3 )
A = B [ 1 ]
if A [ B + C ] [ 0 ] >= 0 :
if A [ B : 9 : 3 ] . count ( C ) == 3 or A [ 3 * B : 3 * B + 3 ] . count ( C ) == 3 :
A [ B ] , C [ B ] = D , E
A = prime_factor ( B )
A , B , C , D = [ 0 ] * E , [ 0 ] * E , [ 0 ] * E , [ 0 ] * E
return A . real * B . real + A . imag * B . imag
del A [ B [ 1 ] [ 0 ] ]
A = [ [ 0 for B in range ( 4 ) ] for C in range ( 4 ) ]
print ( A * B )
A , B = A + 1 , B + 1
print ( A [ B // 100 ] )
A = [ A [ B [ C [ D ] ] [ E ] ] for E in range ( 7 ) ]
A = str ( A ) [ : B + 2 ]
A , B = [ 0 ] * 7 , [ 0 ] * 7
A = len ( B [ 2 ] )
if A [ B ] [ C ] == '*' :
A = 32770
for A in range ( B - 1 , C - 1 , - 1 ) :
A = [ 600 , 800 , 1000 , 1200 , 1400 , 1600 ]
A = B / ( C / 100 ) ** 2
A = list ( sorted ( A ) )
A = calc ( B [ C ] [ 2 ] ) if B [ C ] [ 2 ] > 0 else 1
A , B = 0 , 3
A , B = '' , list ( B )
A = B * C - D
A = B % C
A , B = [ 0 ] * 128 , [ 0 ] * 128
A [ B - 1 ] [ C - 1 ] += 1
C . append ( B )
dijkstra ( A , B , C , D )
A = [ '' ] * B
A = 10 * A + int ( B [ C ] )
A , B , C = True , D , E
A , B = C + D [ E ] , F + G [ E ]
A . sort ( reverse = True )
print ( format ( A [ 0 ] . real + B , '.3f' ) , format ( A [ 0 ] . imag + B , '.3f' ) , format ( A [ 1 ] + B , '.3f' ) )
A = palindrome ( B , C )
A = ''
A += B
A += B * C [ D - E - 1 ]
if int ( A ) + int ( B ) == int ( C ) :
print ( sum ( A ) )
for A in range ( B - 1 , 1 , - 1 ) :
if A == B + 2 :
A . heappush ( B , ( 0 , C ) )
if A + B <= C or B + C <= A or C + A <= B :
A , B = 0 , C [ D ] [ E ]
A = [ 'Sunday' , 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' ]
A = [ B for B in range ( 1 , C + 1 ) ]
A . par = [ - 1 ] * B
if A [ 0 ] == '#' :
print ( 'NA' if A == B else A )
A = int ( B [ C ] [ D ] )
A -= 2 * B
return min ( A , B [ C ] [ 0 ] )
A [ B [ 0 ] - 1 ] += C
break
continue
A , B , C = int ( D [ 1 ] ) , int ( D [ 2 ] ) , int ( D [ 3 ] )
A [ B ] [ C ] = - 1 if D < 0 else C - D
A = False
A = 1e-11
topological_sort ( A , B )
print ( A + 2 )
A , B = 0 , B + 1
print ( A / 2 )
def PPeQ ( a , b ) return EQ ( A . real , B . real ) and EQ ( A . imag , B . imag )
if A > 0 :
A = B [ C ] [ 2 ] * D / E + B [ C ] [ 0 ]
A = B [ 0 ] // C * B [ 1 ]
print ( A + 1 , B + 1 )
if A + B < C :
A = B * 100 + C
A , B , C , D = set ( ) , True , [ 0 ] , 1
rec ( 0 , A , A )
A = 1150
A [ 0 ] , A [ 1 ] = B , C
A [ 2 ] = B = 1
A . append ( 1 << 62 )
A = max ( A , B [ C ] - B [ D ] )
A [ B ] += C
A = [ [ - 1 for B in range ( C ) ] for D in range ( C ) ]
for A in range ( 8 ) :
A , B = C // 2 + 1 , C // 2
for A in range ( 1 , 7 ) :
if ( A & 1 ) or B >= ( 1 << ( A >> 1 ) ) :
A = B . Counter ( C )
for A , B , C in D [ E ] :
if A == B and C == 1 :
print ( A [ B ] [ C // 3 ] [ C % 3 ] )
A = [ B ] * C
if A in B [ C ] :
A = [ '' ] * 7
A = ord ( 'A' )
if A [ B - 1 ] [ C ] [ D ] < E :
A , B = 0 , C + D
A = [ [ B for C in range ( D ) ] for E in range ( D ) ]
A . append ( list ( map ( int , input ( ) . split ( ) ) ) )
if abs ( A . real ) > B or abs ( A . imag ) > B :
print ( 'no' if A * B & 1 else 'yes' )
if A < B - 1 :
A [ B ] = math . sqrt ( A [ B - 1 ] ** 2 + 1 )
for A in range ( 6 ) :
A [ 0 ] [ 2 ] = 1
B = C
while A != 0 :
for A in range ( 2 , len ( B ) ) :
print ( max ( A - B , max ( C >> 1 , D [ 0 ] - 1 ) ) )
A , B = C . pop ( 0 )
A = 2 * int ( input ( ) )
if A [ B - 2 ] [ C ] == '#' or A [ B - 1 ] [ C ] == '#' or A [ B - 1 ] [ C + 1 ] == '#' :
A += B [ C ]
A [ B ] %= C
A , B , C = - D + E , - D - E , F << 1
A = [ B ** 3 for B in range ( 1111 ) ]
A = int ( B . pop ( 0 ) )
A = B * ( B + 1 ) * ( B + 2 ) // 6
if A == '#' :
if A * B > C :
A = [ 2 ]
if A [ B ] == '"' :
A = [ 1 ] * 5
print ( A , int ( B ) + int ( C ) , 200 * int ( B ) + 300 * int ( C ) )
print ( ( A [ B ] [ C ] [ D ] [ D ] + A [ B ] [ C ] [ E ] [ E ] ) % 100000 )
A . heappop ( B )
A = [ [ 0 for B in range ( B + 1 ) ] for C in range ( C + 1 ) ]
print ( 'Yes' if A else 'No' )
A = 3.1415926535897932384626433832795
if A > 0 and B . level [ C ] < 0 :
A , B = term ( )
A = min ( A , B + C [ D - E ] )
A [ B ] = max ( A [ B ] , C )
A [ B ] = ( C , D [ 2 : ] )
if len ( A ) :
A = int ( ( B * C ) ** 0.5 )
if len ( A [ B ] [ 1 ] ) > 0 :
A = [ - 1 ] * B
A , B = int ( C [ 1 ] ) , int ( C [ 2 ] )
if A == 'D' :
A = B [ 1 ] = 2
A = convex_cut ( B , A )
for A in range ( 101 ) :
if A >= 0 and A < 5 and B >= 0 and B < 5 and C >= 0 and C < 5 :
A [ B + 1 ] [ C ] |= 1
A = B [ 0 ] * B [ 5 ] - B [ 3 ] * B [ 2 ]
C = A ^ B
A = ( B + C [ D ] ) / ( E + F )
A = D [ 0 ] if B + 1 == C else D [ B + 1 ]
if A [ B ] [ C ] >= '0' and A [ B ] [ C ] <= '9' :
A = [ [ [ [ 0 for B in range ( 5 ) ] for C in range ( 5 ) ] for D in range ( 5 ) ] for E in range ( 2 ) ]
A [ F ( 't' ) + F ( 'h' ) + F ( 'i' ) + F ( 's' ) ] = ( B , C )
input ( )
print ( A + max ( B , C , D ) )
while len ( A ) > 0 :
A = [ 1 ] * ( 2 * B + 1 )
print ( '{:02d}:{:02d}:{:02d}' . format ( A // 3600 , ( A % 3600 ) // 60 , A % 60 ) )
A += C [ B ] if B in C else B
A , B , C = list ( map ( int , input ( ) . split ( ',' ) ) )
A . par [ B ] += A . par [ C ]
A += '('
A , B = [ 0 ] * C , 0
while len ( A ) or len ( B ) :
move ( A [ B ] [ C ] )
A = UnionSet ( B + 1 )
A , B [ 0 ] , C [ 0 ] = 0 , 1 , int ( input ( ) )
A , B = [ 0 ] * ( C + 1 ) , 0
if A > B or A <= 0 :
while A <= B :
A = 240 * B
A = sorted ( A )
return 1
A = B + 1
A = B + int ( C [ 1 ] ) * D [ E ] [ 1 ]
A [ B ] = min ( - C [ D ] , A [ B ] ) + E [ F ]
A = ( ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) )
if A < 0 or A >= 4 or B < 0 or B >= 4 or C [ B ] [ A ] :
if A [ B ] and A [ C ] :
print ( A ** 3 - len ( set ( B ) ) )
A = [ False ] * B
while A < B or C < D :
A = len ( B )
for A in list ( B . keys ( ) ) :
for A in range ( 0 , len ( B ) , 4 ) :
return 'null'
for A in range ( 13 ) :
for A in range ( 5 , B - 1 , - 1 ) :
A , B [ C ] = A + 1 , B [ C ] + 1
if A % B :
return [ 1 , A . ws [ B ] - A . ws [ C ] ]
print ( C if A > ( B >> 1 ) else 'NO COLOR' )
A , B , C = D . heappop ( E )
if A < B [ C ] and D < E [ C ] :
A = ( B == 0 or B == 2 )
A , B = [ 0 ] * 12 , [ 0 ] * 12
while A != [ ] and A [ 0 ] . isupper ( ) == False :
A , B = 0 , 1000000000.0
if ( A > 0 and B < 0 ) or ( A < 0 and B > 0 ) :
A //= 10
A [ B ] [ C ] [ D ] [ D ] += A [ B ] [ C - 1 ] [ D ] [ D ] + A [ B ] [ C - 1 ] [ E ] [ D ]
A = [ [ 0 for B in range ( 3 ) ] for C in range ( 210 ) ]
A = A - ( A - 1 ) % 5
A = A + ( A * 5 ) // 100
print ( * A [ : B ] )
A = ( B * B + C * C ) ** 0.5
A . heappush ( B , ( 0 , C , 0 ) )
print ( A . replace ( 'Hoshino' , 'Hoshina' ) )
A = 7200 - ( 3600 * B + 60 * C + D )
A , B = A // C , B // C
print ( abs ( A - B ) )
for A in range ( 2 , B ) :
if A % 3 :
A = re . split ( '[., ]' , input ( ) )
if A > B - A :
while A < B and C [ A ] == ' ' :
while A < B and C [ A ] . isalpha ( ) :
print ( 'YES' if isOrthogonalLL ( [ A , B ] , [ C , D ] ) else 'NO' )
print ( A [ B ] * math . cos ( C [ B ] ) , A [ B ] * math . sin ( C [ B ] ) , sep = '\n' )
while A < len ( B ) and B [ A ] == C :
A += B [ 2 ]
A = str ( input ( ) )
return A . ws [ B ]
A += B . pop ( 0 ) . upper ( )
A = int ( B [ 1 ] )
A = [ [ 1 , 2 , 4 , 8 ] , [ 4 , 8 , 1 , 2 ] , [ 8 , 1 , 2 , 4 ] , [ 2 , 4 , 8 , 1 ] ]
if A [ B ] [ C ] != '.' :
A , B , C = list ( map ( int , input ( ) . split ( ) ) )
A = convex_hull ( B )
A [ B ] [ C + 1 ] [ D + 1 ] = min ( A [ B ] [ C + 1 ] [ D + 1 ] , max ( E [ D + 1 ] - E [ C ] , A [ B - 1 ] [ F ] [ C ] ) )
A = [ True ] * ( B + 1 )
return A [ 0 ] + B * C
return A . items [ len ( A . items ) - 1 ]
A = [ 2 ] * ( B + 1 )
A [ B ] = ( int ( C ) , [ ] )
is_atSameSide ( A , B , [ C , D ] )
if check ( A , B ) :
A = [ 0 ] * 26
A = complex ( B [ 6 ] , B [ 7 ] )
A , B = factor ( B )
return A // gcd ( A , B ) * B
A [ ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ] = 0
A = 15
if A == 'xy' :
A [ B ] = - getInt ( )
A = [ True for B in range ( C ) ]
print ( 1 )
print ( A - sum ( B [ C : A + 1 ] ) )
A = swap ( B , C , D )
if A [ B & 1 ] [ C ] == A [ B & 1 ] [ C - 1 ] :
if A [ B ] == C [ B ] :
print ( 'Open' if A == 1 or A == 6 else 'Close' )
A , B , C = [ 0 ] , [ 0 ] , [ 0 ]
A = min ( A , calc ( B ) + 1 )
A += B [ 0 ]
combi ( A , 20 )
A = 25
if A [ B ] [ C ] == 1 :
A [ B + 1 ] [ C + 1 ] += 1
print ( ( A - B - C ) // ( D - 2 ) )
A = B + 6
A = [ 0 ] * 60
if A < 2 :
A = [ B [ C : C + 3 ] for C in range ( len ( B ) - 2 ) ]
A = 720 - B
A = B - C
if A [ 0 ] == 1 :
if A [ 2 ] == 2 :
if A and A . group ( 1 ) == A . group ( 2 ) :
A = [ 'A' , 'B' , 'AB' , 'O' ]
for A in range ( B * B , C , B ) :
A , B , C = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) )
A . heappush ( B , ( - C , D ) )
print ( A , B , C )
A = 1000004
A = B
print ( A - B + 1 , C - D + 1 )
A = [ 0.0 ] * 2
A = 50025
print ( 1 + A . index ( max ( A ) ) )
A , B , C = map ( int , input ( ) . split ( ',' ) )
if A [ 0 ] == 'FORWARD' :
A , B , C , D = [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002
if A [ B ] [ C ] == 'c' :
A [ B % 3 ] [ C + 1 ] = min ( A [ B % 3 ] [ C + 1 ] , A [ B // 3 ] [ C ] + D [ B // 3 ] [ B % 3 ] [ E [ 0 ] [ C ] ] [ E [ 1 ] [ C ] ] + 1 )
def vabs ( a ) return math . hypot ( A . real , A . imag )
for A in range ( 2 , B + 1 ) :
print ( A if A < B else 'Impossible' )
if A [ B ] != A [ B - 1 ] + 1 :
A = [ [ 0 for B in range ( 3 ) ] for C in range ( 101 ) ]
A = B / Decimal ( C )
print ( - 1 if A < 0 else A + B * C )
A = [ [ 0 for B in range ( 4 ) ] for C in range ( 2 ) ]
A += B [ C ] // 3
A = bisect_left ( B , int ( C [ 1 ] ) )
if A [ B ] and A [ B - 2 ] :
A . extend ( B )
print ( 'OK' if A ^ B else 'NG' )
A = sum ( B )
if len ( str ( A ) ) <= 80 :
print ( bisect_left ( A , B ) )
A , B = [ 0 ] * 100003 , [ 0 ] * 100003
A , B = C [ D ] , 1
A = [ - 1 for B in range ( C ) ]
if A and B != 5 :
if A [ B ] >= 1000000 :
A = sorted ( B . items ( ) , key = lambda x : C [ 1 ] , reverse = True )
A [ B [ C + 1 ] ] = C + 1
if A > 2 :
if A [ 0 ] == 'STOP' :
A = [ 0 ] * 31
A = [ - 1 , 0 , 1 , 0 ]
A [ 61 ] , A [ 62 ] , A [ 63 ] , A [ 64 ] , A [ 65 ] = 'z' , '.' , '?' , '!' , ' '
print ( A [ 1 ] )
A = max ( A , B [ C ] + B [ D ] )
A = B . bisect_left ( C , D )
A = ( 3600 * B + 60 * C + D ) - ( 3600 * E + 60 * F + G )
A = B = C = 0
print ( A + 1 , ':' , '*' * B [ A ] , sep = '' )
A = [ int ( input ( ) ) for B in range ( C ) ]
A = [ [ - 1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] ]
A , B = A + 1 , True
A = B . bisect_left ( C , D >> 1 , 0 , E )
if A > 255 :
if A != '0' :
A . append ( complex ( B + C * D , E - C * F ) )
A = [ 0 , 1 , 2 , 4 , 6 , 16 , 12 , 64 , 24 , 36 , 48 , 1024 , 60 ]
A = B + C
A = dijkstra ( B , C , 0 )
while 1 :
if A [ B ] >= C and A [ B ] > A [ D ] :
if A [ B ] >= '0' and A [ B ] <= '9' :
for A in range ( int ( B ) ) :
A = 323
A = B [ 2 ] * B [ 4 ] - B [ 5 ] * B [ 1 ]
if PPeQ ( A , 0 ) :
A , B = list ( C ) , list ( C )
for A in range ( 6 , - 1 , - 1 ) :
A = B ^ C [ D ] [ E ] [ F ] [ G ]
A = B . split ( '&' )
A , B = map ( int , input ( ) . split ( ',' ) )
return tuple ( A )
A . sort ( key = lambda x : ( B [ 0 ] , B [ 1 ] ) )
if A == 0 or B [ A ] >= 0 :
A = [ B for B in range ( 7 ) ]
combi ( A + 1 , B , C + D [ E ] [ 2 ] )
A [ B ] = C [ D ]
A , B = int ( input ( ) ) , int ( input ( ) )
A += [ B + C for C in range ( D ) ]
for A in range ( 26 - 3 ) :
A . append ( ( B + C ) * D )
A = 3 - A
A . power = [ 0 ] * B
A = sum ( B [ C : D ] )
A = Stack ( )
A [ re ] = 1
for A in sys . stdin :
for A , B in C :
if A > B [ C + 1 ] :
if A [ B - 1 ] == 0 :
if A [ B ] + A [ C - 1 ] > D :
A = [ 0 ] * 300005
A = [ [ B for C in range ( D + 1 ) ] for E in range ( F + 1 ) ]
A = [ 0 , 9 , 26 , 50 , 80 , 115 , 154 , 196 , 240 , 285 , 330 ]
C [ A ] . append ( int ( B [ 2 ] ) )
A = [ [ B for C in range ( D + 2 ) ] for E in range ( 3 ) ]
if A + 1 > B :
A . append ( ( B , C ) )
for A in range ( 1 , 8 , 2 ) :
A [ B ] = complex ( C , D )
for A in range ( 3 ) :
A [ 'A' ] , A [ 'B' ] , A [ 'C' ] = 'X' , 'Y' , 'Z'
print ( A [ B ] + ' ' , end = '' )
A , B = C [ D ] , E [ F ]
print ( A [ B & 1 ] [ C ] )
A += [ B + ( C << 9 ) for C in range ( D ) ]
A = B [ C ] + D
if A <= 0 :
A = B [ C ] - 1
A . id [ B ] = A . id [ A . id [ B ] ]
if len ( set ( A ) ) == 1 or len ( set ( A ) ) == 3 :
A = [ int ( input ( ) ) for B in range ( C ) ] [ : : - 1 ]
for A in range ( 1 , 2 * B [ 0 ] , 2 ) :
A [ B ] += math . sin ( C * D ) * math . cos ( C * D )
A = True
A [ 51 ] , A [ 52 ] , A [ 53 ] , A [ 54 ] , A [ 55 ] = 'u' , 'v' , 'w' , 'x' , 'y'
if ( A % B ) == 0 :
A = [ [ [ [ 0 for B in range ( 2 ) ] for C in range ( 2 ) ] for D in range ( E + 1 ) ] for F in range ( G + 1 ) ]
if A > B or ( C <= D and E [ C ] == 0 ) :
A [ B ] = C + 1
if A [ B ] % C > A [ B + 1 ] % C :
A = B + C / D
if abs ( A [ 1 ] - A [ 0 ] ) <= B :
if A >= 4 :
A = B [ 0 ] [ C ]
A = list ( B . split ( ) )
if A - B <= 8 :
while A != B . id [ A ] :
A = [ 0 ] * 1001
for A in range ( 1 , 16 ) :
print ( max ( A , key = A . count ) , max ( A , key = B ) )
A = [ [ 0 for B in range ( 21 ) ] for C in range ( 2 ) ]
A = bisect_left ( B , C [ 1 ] )
if A [ B ] == '@' :
re = A [ B ]
return A . items . pop ( )
A = 1003
return A . real * B . imag - A . imag * B . real
if A == 6 :
D = A + ( B - 1 ) * C
A [ int ( B [ 1 ] ) ] += 1
A = B [ C ] [ D ] + E + B [ F ] [ G ]
if A < 19 :
A += 2
if A [ B ] == '1' :
A . append ( [ B , C ] )
A = B / 2
A = [ 1 , 2 , 1 , 0 ]
while A != [ ] :
for A in range ( B , 11 ) :
A = 10000
print ( int ( '' . join ( sorted ( A , reverse = True ) ) ) - int ( '' . join ( sorted ( A ) ) ) )
print ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) // ( A - 1 ) )
A [ B ] [ C ] [ D ] [ D ] += A [ B - 1 ] [ C ] [ D ] [ D ] + A [ B - 1 ] [ C ] [ E ] [ D ]
A , B = 1 , [ 0 ] * C
A = 22.0
A , B = C + D [ E << 1 ] , F + D [ ( E << 1 ) + 1 ]
A = E if B and C [ D + 1 ] else 0
if A [ B ] == 0 or C > D [ B ] :
A [ B + 1 ] = A [ B ] = C
while A and len ( B ) :
A [ B - 2 ] [ C ] += 1
A += ','
if A [ B ] [ 0 ] == 0 :
A *= 1 + B
A [ 1 ] = True
if A == 3 :
print ( A [ B - 1 ] )
A = B . root ( C )
A , B = [ ] , { }
if A [ B ] > C :
A , B = B , C
while A < B and C [ A ] . isdigit ( ) :
print ( calc ( A ) )
A , B , C = 3 , 4 , 1
for A in range ( 1 , B ) :
A = calc ( )
if A [ B ] < C [ B ] :
if A [ B ] != C [ D ] :
if A > B + 4 * C :
for A in range ( B - C , B ) :
A = ord ( B ) - C
for A in range ( 2 ) :
for A in range ( B - C ) :
A [ B + 2 ] [ C ] += 1
A [ 0 ] [ B ] = list ( input ( ) )
A = [ 0 ] * ( B + 1 )
if A < len ( B ) :
A = set ( list ( map ( int , input ( ) . split ( ) ) ) )
A [ B + 1 ] = A [ B ] + C [ B ]
print ( A , B )
A [ 0 ] [ 0 ] = 1
if A [ B ] + C [ B ] == C [ 0 ] :
print ( 'OK' )
if not A :
print ( A [ B ] [ C ] + 1 if A [ B ] [ C ] < D else 'NA' )
A , B = [ int ( input ( ) ) for C in range ( 2 ) ]
A = B // C
if not A [ B ] and not A [ C ] :
if A [ B ] and C + B <= 20 :
A = Decimal ( 1 )
A , B = [ C ] * D , [ 0 ] * D
if A [ 0 ] == '.' :
A = 50
A [ B ] = C [ ord ( D [ B ] ) - ord ( 'a' ) + E ]
if len ( A ) < B + 2 :
return A [ 0 : B - 1 ]
if A [ 0 ] == 'i' :
if factor ( 0 ) [ 0 ] == 2 :
A = deque ( )
A = 'L'
if A [ B ] [ C ] == D :
for A in range ( 26 ) :
if A . isdigit ( ) :
for A in range ( B , 21 ) :
A = math . sqrt ( 4 * B * B + C * C ) + C
print ( A [ B ] - 2 , A [ B ] )
if A [ B ] [ C + 2 ] == '#' or A [ B ] [ C + 1 ] == '#' or A [ B + 1 ] [ C + 1 ] == '#' :
if A [ B ] > A [ C - B ] + D :
if A [ B [ C ] [ D ] ] [ D ] == 1 :
A , B = d2t ( A ) , d2t ( B )
A = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ]
A , B = [ 0 ] * 100005 , [ 0 ] * 100005
for A in range ( 1 , B + 1 , 1 + ( B & 1 ) ) :
A [ B : ] = A [ : B - 1 : - 1 ]
A = 50000
if A [ B ] == 'O' :
A = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ]
A , B , C = 1 , 0 , D
print ( * sorted ( map ( int , A [ B ] ) ) )
A . append ( [ B , C , 0 ] )
print ( B + A + 1 if A > 0 else 'NA' )
A = complex ( B [ 4 ] , B [ 5 ] )
if ( A | B ) == 0 :
A = B [ C : D ]
import sys
A = [ [ 0 for B in range ( C ) ] for D in range ( 2 ) ]
if A [ 0 ] == '-' :
for A in sorted ( B , key = lambda x : ( - C [ 2 ] , C [ 1 ] ) ) :
A += B - C
print ( 'Case ' , A , ':' , sep = '' )
A , B = list ( map ( float , input ( ) . split ( ) ) )
A = B // C [ D ]
print ( 'Yes' )
for A in range ( B - 2 , - 1 , - 1 ) :
A = B = C >> 1
A = 0
print ( 1 if A == 0 else A )
print ( A . maxFlow ( B - 1 , C - 1 ) )
if len ( A ) and A [ 0 ] == B :
A , B = len ( C ) , D
while A [ 0 ] > 0 and A [ 1 ] > 0 :
A = B ** 2 - 4 * C * D
if A [ 0 ] == '(' :
return max ( abs ( A - B ) , abs ( C - D ) )
A = min ( len ( B ) , 5 )
A += 'D'
while A [ 99 ] == 0 :
A = abs ( B - C )
A , B = [ 0 ] * 8 , [ 0 ] * 8
if A >= 0 and B >= 0 and A <= 9 and B <= 9 and C [ D ] [ A ] [ B ] :
A = [ 0 ] * 126
A = len ( B [ 1 ] )
if combi ( A , B - 2 ) :
A = A [ : B ] + A [ C : D ] + A [ E : C ] + A [ B : E ] + A [ D : ]
if A < 0 or A >= B or C < 0 or C >= D :
if A . root ( B ) == B :
A = 100000
A . sort ( key = lambda x : ( len ( B [ 0 ] ) , B [ 0 ] ) )
A , B , C = B , C , 1
if A [ B ] == C :
A = B + C / D [ E ]
if A [ 0 ] == 0 :
A = '(J*)(O*)(I*)'
print ( min ( A , B ) )
if A != B [ C ] [ 0 ] :
A = [ [ 0 for B in range ( 51 ) ] for C in range ( 51 ) ]
A += B * C - D
A = B [ C ] [ 0 ] * D [ C ]
A . append ( [ B , C , 3 * int ( D ) + int ( E ) ] )
A += ( B [ C ] - B [ D + 1 ] ) * E [ D ]
pushBack ( A + B , A + C )
for A in range ( - 1 , 2 ) :
if A == 'HIT' :
return [ A , dist ( A , B ) ]
while A < B and C [ A ] == C [ A - 1 ] + 1 :
A [ B + C + D + E ] += 1
A , B = [ ] , len ( C )
print ( A + 1 )
A += 3
A [ 0 ] [ 0 ] = 0
A , B = C [ D ] - 1 , C [ D + 1 ] - 1
A = 100
A . extend ( list ( map ( int , input ( ) . split ( ) ) ) )
for A in range ( B , 10 ) :
print ( A . real , A . imag )
if A * B < 0 :
A = 250000
A //= - B
A , B = map ( float , input ( ) . split ( ',' ) )
return A + calc ( B >> 1 , C >> 1 )
for A in range ( 47 ) :
for A in range ( B , 5 ) :
while A >= 0 and B [ A ] <= B [ A + 1 ] :
A = 1001
A = list ( B . split ( '|' ) )
print ( 'LOOP' )
if A >= 60 :
try :
A , B = 0 , 1
if A < 60 :
print ( A [ B : C ] . count ( D ) )
A , B , C = 0 , 90 * D , 0
return A <= B and B <= C and D <= E and E <= F
print ( int ( A * math . cos ( B ) ) , int ( A * math . sin ( B ) ) , sep = '\n' )
A = [ 0 ] * 4
import heapq
A = 'U'
for A in range ( 4 ) :
A [ B ] , A [ C ] = A [ C ] , A [ B ]
return complex ( ( A [ 0 ] . real * B - A [ 1 ] . real * C ) / ( B - C ) , ( A [ 0 ] . imag * B - A [ 1 ] . imag * C ) / ( B - C ) )
if len ( A ) == 0 :
for A in range ( 1 , 6 ) :
print ( A [ 0 ] , A [ 1 ] )
A = symmetric_Point ( B , C )
if A [ B ] >= 3 :
print ( A - B + 1 )
B = sorted ( B )
A = [ '0' , '90' , '180' , '270' ]
A [ B ] [ C ] = '0'
A [ B + 1 ] = A [ B ] + ( C [ B ] == 'I' )
if A == 0 and B == 0 and C == 0 :
A += 15 * B + ( 15 - 2 ) * 3 * B
A = B [ A ]
A = [ 0 , 4 , 13 , 27 , 45 , 67 , 94 , 126 , 162 , 202 , 247 ]
if A <= 30 :
A , B = [ 0 ] * ( C + 1 ) , [ 0 ] * ( C + 1 )
print ( A - sum ( [ int ( input ( ) ) for B in range ( 9 ) ] ) )
A = ord ( B ) - ord ( 'A' )
A = list ( map ( int , B ) )
if A [ B ] == 2 :
if A [ B + 2 ] == 'a' :
print ( * [ A [ B ] [ 1 ] for B in range ( C ) ] )
A . heappush ( B , ( 0 , 0 , 0 , 1 ) )
combi ( 2 )
if A % B > ( B - 1 ) // 2 :
A [ B ] += C [ D ]
if A [ B - 1 ] [ C ] == 0 :
while A < B :
A = [ [ 0 for B in range ( 102 ) ] for C in range ( 102 ) ]
A = [ [ 0 for B in range ( 15 ) ] for C in range ( 2 ) ]
A , B = C [ D ]
act ( 0 , 2 if A == 'i' else 1 )
A += B // C
if A == 2 * B :
A , B = len ( C . edge [ D ] ) , len ( C . edge [ E ] )
A = int ( '' . join ( input ( ) . split ( ) ) , 2 )
A [ 11 ] , A [ 12 ] , A [ 13 ] , A [ 14 ] , A [ 15 ] = 'a' , 'b' , 'c' , 'd' , 'e'
A = [ 0 for B in range ( C + 2 ) ]
A , B = map ( int , input ( ) . split ( ) )
A [ B ] [ C ] = 1
A [ B + 1 ] [ C ] = 1 - E if D == 2 else E
print ( A [ B ] - C )
while A > 0 :
A . par [ B ] = C
A = B + 30
A . sort ( key = lambda x : ( - B [ 1 ] ) )
if A * A + B * B == C * C :
A , B = C / D , D
for A in range ( 9 ) :
A = [ [ 0 for B in range ( C ) ] for D in range ( E + 1 ) ]
A . append ( 0 )
A = min ( A , B )
A = 360 - B [ C ]
A [ B ] = [ C for C in range ( D ) ]
if A - B * C < 0 :
if A [ B ] == '(' :
A = 37
A . heappush ( B , ( C , D , E , F ) )
while next_permutation ( A ) :
print ( calc_area ( A ) )
A = 'A'
print ( rec ( A , B , 0 ) )
while A < B * B :
for A in list ( input ( ) . split ( ) ) :
A = [ 0 , 0 , 1 , 4 , 10 , 20 , 35 , 56 , 84 , 120 , 165 ]
while A * A < B :
A = [ 41412121 , 14121214 , 41212141 , 12121414 , 21214141 , 12141412 , 21414121 , 14141212 ]
if A [ B ] [ 1 ] > 0 :
A , B , C , D = map ( int , input ( ) . split ( ) )
A = 104729
A = A . replace ( 'peach' , 'apple' )
if A == B - 1 and C == D - 1 :
A = { PLUS : 2 , MINUS : 2 , MUL : 3 , DIV : 3 , LEFT : 1 , RIGHT : 1 }
A = 3 * 0xff ** 2
A , B = map ( int , C . split ( ':' ) )
return A [ 0 ]
A = [ 0 ] * 128
return root ( A ) == root ( B )
A . append ( 1000000001 )
A , B , C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )
for A in range ( 1 , B + 1 ) :
A = B * C - D * E - F * G - H * I
A = B + 2
A . sort ( )
if ( A [ 1 ] & 1 ) and ( A [ 2 ] & 1 ) :
A , B = C [ 3 : ] . split ( )
A = 0.00001 * B
return A [ B ]
print ( 'No\n' )
A . add ( C )
( A [ B ] , A [ C ] ) = ( A [ C ] , A [ B ] )
A , B = dijkstra ( C , D , C - 1 )
if A [ 0 ] > 0 :
A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) )
C += D
if A * B >= 0 :
print ( * A [ 1 ] )
for A in range ( 5 , B , 2 ) :
A -= B [ 0 ]
A = B // gcd ( B , C ) * C
A = 0.00872664625997164788461845384244
if EQ ( A , 4 ) :
print ( gcd ( A [ 0 ] , A [ 1 ] ) , lcm ( A [ 0 ] , A [ 1 ] ) )
A = [ [ 0 for B in range ( 1001 ) ] for C in range ( 11 ) ]
for A in B :
A . id [ B ] = C
if A [ B ] :
A . append ( B - C )
if A - B [ C ] - B [ D ] >= E :
A , B , C , D = E - F , G - F , E + F , G + F
A = [ B , B + ( C - D ) * complex ( 0 , 1 ) ]
A [ B ] [ 2 ] += 1
for A in range ( 225 , B + 1 , 2 ) :
A , B = 0 , C - 1
print ( input ( ) . upper ( ) )
if A . level [ B ] < 0 :
for A in range ( 5 * B ) :
A [ B ] [ 1 ] [ C ] [ C ] = A [ 1 ] [ D ] [ E ] [ E ] = 0
if clause ( A [ 1 : - 1 ] ) :
print ( A [ 0 : 8 ] , sep = '' )
for A in range ( 12 ) :
A *= B
for A in range ( 21 - B ) :
A = 0.0001
if A + 1 >= len ( B ) :
A , B = A + C , B + 1
A = [ 10 , 12 , 15 ]
A = [ [ 0 for B in range ( 1002 ) ] for C in range ( 1002 ) ]
A [ 0 ] [ 0 ] [ 1 ] = 0
print ( 'YES' if A ** 2 + B ** 2 == C ** 2 else 'NO' )
while A >= B :
rec ( A + 1 , B + C , D + E )
if A > B :
A , B = ( C . real + D . real ) / 2 , ( C . imag + D . imag ) / 2
A = { "North" : 1 , "East" : 2 , "West" : 3 , "South" : 4 , "Right" : 5 , "Left" : 6 }
A [ 0 ] [ B // 3 ] [ B % 3 ] = 1
if A [ B ] < A [ C ] :
print ( 'myon' * calc ( A ) )
for A in range ( 21 ) :
A [ B & 1 ] = 1
print ( 'OK' if A <= B else 'NA' )
print ( '' . join ( A [ 1 : B + 1 ] ) )
if A [ B ] in C :
A . ws = [ 0 ] * B
if 3 <= len ( A ) <= 6 :
print ( sum ( A [ B : C + 1 ] ) )
A , B , C , D , E , F = list ( map ( int , input ( ) . split ( ) ) )
A = ngcd ( B , C )
if A >= B and C >= B :
print ( A >> 1 )
A [ 2 * B - 1 - C - D ] [ D ] = E
A = A + A
A . append ( complex ( B - C * D , E + C * F ) )
A = [ 0 ] * 100
print ( 'YES' if judge ( A , B , C , D , E , F , G , H ) else 'NO' )
A = input ( ) . split ( )
print ( A . replace ( '_____' , 'peach' ) )
A = max ( A , B [ C ] [ D ] )
while A >= B [ C ] :
A = B [ C ] - B [ C + 1 ]
A . size = [ 1 ] * B
if A [ 0 ] != ')' :
A , B , C = list ( input ( ) . split ( ',' ) )
A . append ( ( ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) , 0 ) )
if A in [ '+' , '-' , '*' , '/' ] :
A = B * B
A = B = C - D + 1
print ( 196666 - A - B )
A , B = list ( map ( int , input ( ) . split ( ',' ) ) )
if A [ B ] != '' :
A += 100
print ( * A [ 0 ] )
A = [ B for B in range ( 1 , 31 ) ]
print ( A [ 0 ] [ B - 1 ] )
A , B = list ( map ( int , input ( ) . split ( ':' ) ) )
A *= 2
A [ B ] = list ( map ( int , input ( ) . split ( ) ) )
for A in range ( B + 1 , C + 1 ) :
A += 'U'
A = B [ 0 ] * B [ 4 ] - B [ 3 ] * B [ 1 ]
for A in range ( 7 ) :
A . unite ( B [ 0 ] , B [ 1 ] )
A , B , C = list ( input ( ) . split ( ) )
A [ B ] [ C ] [ D ] [ D ] %= 100000
if A [ B + C ] == 'Y' :
A *= 5
A , B , C = D . edge [ E ] [ F ]
print ( 'yes' if A else 'no' )
if A > ( B + C ) * ( B + C ) :
A = len ( B ) - 1
A = B = C = D = 0
if ( A <= 50 and B [ A ] == 0 ) or B [ A ] > C :
A = complex ( 0 , 1 )
print ( A [ B ] )
A = { 1 : 6000 , 2 : 4000 , 3 : 3000 , 4 : 2000 }
A [ B ] . append ( sum ( A [ B ] ) )
A = [ 71.0 , 77.0 , 83.0 , 89.0 , 105.0 , 116.0 , 148.0 , 1000.0 ]
if A >= 0 and B >= 0 and A <= 9 and B <= 9 :
def connected ( self , x , y ) return A . find ( B ) == A . find ( C )
A = 0x7fffffff
A += shortpath ( B , C , D , E )
def connected ( self , p , q ) return A . root ( B ) == A . root ( C )
A += min ( B , C )
A [ 0 ] = input ( ) . strip ( )
A [ B ] , C [ B ] , D [ B ] , E [ B ] = map ( int , input ( ) . split ( ) )
print ( A if A <= B else - 1 )
if leap_year ( A ) :
A = 2002
A = 2 - A
print ( get ( A ) )
print ( A if abs ( A - B ) <= C or A <= B else 'impossible' )
for A in range ( 1 , 126 ) :
A = B + C + D
if A == B - 1 :
A [ 1 ] , A [ 2 ] = 1 , 2
for A in range ( B [ 0 ] ) :
A . push ( B )
for A in range ( 1 + ( B >> 1 ) ) :
A = set ( )
A [ B ] [ C + 1 ] += 1
A = 10 * B + C
print ( A // 3600 , ( A % 3600 ) // 60 , A % 60 )
A , B [ 0 ] = 0 , 1
A = [ [ 0 for B in range ( 105 ) ] for C in range ( 105 ) ]
A = re . match ( B , C )
A = ( B . imag - C . imag ) / 2
A = B [ : 2 ]
A -= B . power [ C ] + B . weight ( C )
print ( 'YES' if isParallelLL ( [ A , B ] , [ C , D ] ) else 'NO' )
if A [ B ] [ C ] == '1' :
A = list ( B )
if EQ ( A [ B ] . imag , 0 ) and EQ ( A [ C ] . imag , 0 ) :
A . heappush ( B , ( 0 , C , - 1 , 0 ) )
print ( A [ B ] [ int ( input ( ) ) ] )
print ( 4280 - A )
A , B , C = [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3
if A [ B ] != '0' :
if A + 1 < len ( B ) and C [ B [ A ] ] < C [ B [ A + 1 ] ] :
A [ B + 1 ] [ C ] = max ( A [ B + 1 ] [ C ] , A [ B ] [ C ] )
A , B = list ( input ( ) ) , 0
for A in range ( B + 4 ) :
A , B = C + 1 , 2
A = calc ( B [ C ] [ 3 ] ) if B [ C ] [ 3 ] > 0 else 1
A , B = C [ 10 ] , C [ 11 ]
A [ B ] [ C ] = D = 1
A , B = [ 1 ] * 16 , [ 0 ] * 16
A [ B ] = - 1
print ( sum ( [ int ( input ( ) ) for A in range ( B >> 2 ) ] ) )
A = [ [ 0 for B in range ( 27 ) ] for C in range ( 27 ) ]
print ( ut2jd ( A , B , C ) - ut2jd ( D , E , F ) )
print ( kruskal ( A , B ) )
A = ( A + B ) % C
if not A . connected ( B [ 0 ] , B [ 1 ] ) :
A [ B ] . append ( C )
if A == '.' :
print ( '3C' , format ( A , '02d' ) , sep = '' )
if A + 1 < B :
A = B * C + D * E
A = [ [ 0 for B in range ( C ) ] for D in range ( C ) ]
A , B = list ( input ( ) . split ( ',' ) )
A . append ( ( B // 100 - 1 , C , D ) )
A . update ( B )
A [ B ] = A [ B - 1 ] - C [ B - 1 ]
A . sort ( key = lambda x : ( B [ 0 ] , B [ 2 ] ) )
A = ( ( A - 1 ) // 1000 + 1 ) * 1000
A , B = [ 0.0 ] * C , [ 0.0 ] * C
A , B = 1 , 0
A = A ** 0.5
while A != [ ] and A [ 0 ] != '_' :
A , B = B , A
A , B = 1 , C [ 0 ]
A = B + int ( C [ 1 ] ) * D [ E ] [ 0 ]
print ( A // 3600 , ':' , ( A % 3600 ) // 60 , ':' , A % 60 , sep = '' )
A = 20
A = list ( map ( int , input ( ) . split ( ) ) )
if A [ B ] [ C ] . isdigit ( ) :
for A in range ( 5 ) :
A [ B ] , C [ B ] = 0 , 1
A = min ( B )
A = [ [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] ]
print ( A - B )
if A [ B ] [ C - 1 ] == 0 :
return A . real ** 2 + A . imag ** 2
print ( calc ( ) [ 15 ] )
A = list ( map ( int , input ( ) ) )
A = list ( map ( float , input ( ) . split ( ) ) )
C = ( A / 100 + 1 ) ** B
for A in B [ C ] :
while A [ B ] <= A [ C ] :
A , B = C [ D << 1 ] , C [ ( D << 1 ) + 1 ]
A . level [ B ] = A . level [ C ] + 1
if A [ B + 2 ] [ C ] == '#' or A [ B + 1 ] [ C ] == '#' or A [ B + 1 ] [ C - 1 ] == '#' :
A = 10 * A + ( B % 10 )
for A in range ( 3 , 31 ) :
A , B = [ 0 ] * 62 , [ 0 ] * 62
A , B = C [ 0 ] , D
A . level [ B ] = 0
if A < 0 :
print ( 'yes' if A . connected ( B , C ) else 'no' )
if A [ B ] . isdigit ( ) and A [ B + 1 ] . isdigit ( ) :
A = B [ 0 ] = int ( input ( ) )
A , B = - 1 , 0
A = 1000000010
A = [ 0 ] * 5001
if A >= B and C == 0 :
A = [ [ 0 for B in range ( 100 ) ] for C in range ( 100 ) ]
A = dijkstra ( B , C , D , E )
A , B = [ 0 ] * 3 , [ 0 ] * 3
A = B + int ( input ( ) )
A = [ 18680908 , 19120730 , 19261225 , 19890108 , 99999999 ]
A = B [ C - 1 ] [ 2 ] * D / E + B [ C - 1 ] [ 0 ]
A = 1000000
A , B = ord ( 'a' ) , ord ( 'z' ) + 1
print ( A + B + C , A , B , C )
A = min ( A , B [ C + D ] )
print ( 'overflow' )
if A == 1 :
for A in range ( 2 , 12 ) :
A = B . pop ( 0 )
A [ B * C ] = 1
C = A [ B ]
return 'd'
if A < 0 or B < 0 or C < 0 or D < 0 or E < 0 or F < 0 :
A = [ [ B for C in range ( 101 ) ] for D in range ( 101 ) ]
A = B >> 1
if A < B and C == D [ A ] :
for A in range ( B , C + 1 , D ) :
A , B = 100000 , 1000000000
A , B = [ ] , '>'
if A < B :
print ( A , len ( set ( B ) & set ( C ) ) - A )
if A == '*' :
A . append ( ( B , - C ) )
A , B , C , D = map ( int , list ( E ) )
for A in range ( 3 , 1 + ( B >> 1 ) , 2 ) :
A = int ( B ** 0.5 )
A , B , C = 0 , int ( D ) , C + 1
A = 182
A . append ( 1 )
del A [ 0 ]
A , B , C = 1 , 1 , 1
A , B = C . split ( '.' )
if A [ B ] [ 1 ] == 0 :
A = [ 1520 , 1870 , 2244 ]
if C [ A [ B ] ] > 0 :
if A [ B - 1 ] >= C :
if A < B and ( C < 0 or D [ A ] < C ) :
A = { 0 : '.' , 1 : 'E' }
print ( A * math . sin ( B / A ) * math . cos ( C * B / A ) / math . cos ( ( C - 1 ) * B / A ) )
print ( calc ( 0 , 0 ) [ 0 ] )
A , B , C = 1 , D , D
A = [ True for B in range ( C + 2 ) ]
A = ( B * C ) % ( C + D )
A [ 31 ] , A [ 32 ] , A [ 33 ] , A [ 34 ] , A [ 35 ] = 'k' , 'l' , 'm' , 'n' , 'o'
for A in range ( B // 2 ) :
for A in range ( B + 1 , 6 ) :
A [ B ] [ C ] = max ( D , E , F )
A = [ [ [ B for C in range ( 31 ) ] for D in range ( E ) ] for F in range ( E ) ]
A [ 0 ] = B [ 0 ] = C = D = E = F = 200
A = dot ( B - C [ 0 ] , D ) / norm ( D )
print ( A % 3 + 1 )
A = format ( B , '08b' )
if A >= B + C :
if float ( A ) / float ( B ) ** 2 >= 25 :
A = B // C [ D ] * E [ D ] + ( B % C [ D ] ) // F [ D ] * G [ D ]
for A in range ( 1 , len ( B ) ) :
B [ A ] = [ ]
print ( 2 )
A = B . dfs ( C , D , E )
if A > B [ C ] [ D ] - B [ C ] [ E - 1 ] :
print ( * A [ : : - 1 ] )
A = B = - 1
print ( min ( A , ( ( B * C + D * E ) * 4 ) // 5 ) )
if not A [ B ] [ C ] :
A = dcmp ( cross ( B [ 1 ] - B [ 0 ] , C [ D ] - B [ 0 ] ) )
A = list ( sorted ( B . items ( ) , key = lambda x : A [ 1 ] ) )
A = B [ 0 : ]
for A in range ( B , B + 1001 ) :
A = 2
A = [ [ [ 0 for B in range ( 10 ) ] for C in range ( 10 ) ] for D in range ( 10 ) ]
if A [ B ] and A [ C - B ] :
A = 5 if ( B % 5 ) == 1 else 2
for A in range ( B + 1 , C ) :
A = A [ : B ]
A = [ True ] * 11
A , B = int ( A ) - 1 , int ( B ) - 1
if A [ B ] [ 0 ] <= C and C <= A [ B ] [ 1 ] :
if A <= 60 :
A = [ len ( input ( ) ) for B in range ( C ) ]
if inside ( A , B , C , D , E , F ) :
A . unite ( B , C )
for A in range ( 1 , 4 ) :
A = B + C [ D ]
A [ B ] [ C ] += 1
A = gcd ( B [ 0 ] , B [ 1 ] )
for A in range ( B , C + 1 , B ) :
A = [ 0 ] + [ int ( input ( ) ) for B in range ( C ) ]
print ( 'impossible' if A < 0 else A )
A , B = factor ( )
print ( A - len ( convex_hull ( B ) ) )
A += B [ C & 1 ] [ D ] [ E ] [ F ] & 1
A = ( 500 , 100 , 50 , 10 , 5 , 1 )
A = 17
A , B = [ 0 ] * 200 , 0
A = float ( input ( ) )
A = B | ( 1 << C )
A = [ [ [ 0 for B in range ( 8 ) ] for C in range ( 8 ) ] for D in range ( 4 ) ]
A = [ 0 ] * 2
A , B [ C ] [ 0 ] , D , B [ C ] [ 1 ] = map ( int , input ( ) . split ( ) )
if ( A >= B and C <= D ) or ( A <= B and C >= D ) :
A [ B [ C ] - 1 ] += D
return A * B + C
while A [ B ] != '0' :
A = get ( B )
A = B + 4
A = B [ C + 2 ] - 1
A = B + 3
A [ B + C ] [ 0 ] = D
for A in range ( B - 1 ) :
A = max ( - 3 , min ( 3 , B [ 1 ] - B [ 2 ] ) )
if A < 0 or A >= B or C < 0 or C >= D or not E [ A ] [ C ] :
A , B = list ( map ( float , input ( ) . split ( ',' ) ) )
if A [ B ] == C - 1 :
print ( A // B + 1 )
B = A + 1
A [ 0 ] , A [ B ] , A [ C ] = 1 , 1 , 1
A = B [ C ] + 1
A -= 1
A = MaxFlow ( B )
A , B = [ ] , 0
A = 10e8
A [ B ] , A [ B + 1 ] = A [ B + 1 ] , A [ B ]
A = 10001
A [ B ] = A [ B - 1 ] - 1
if A >= 2 :
while A < B [ C ] :
A , B , C , D , E , F = map ( int , input ( ) . split ( ) )
for A in range ( B , 0 , - 1 ) :
A = A - B / ( 3 * C )
A . iter = [ 0 ] * A . V
A [ B ] = 0
pushBack ( A , B )
A = 0
A = 1e-8
A = B [ C ] - B [ D - 1 ]
A . edge [ B ] [ C ] [ 1 ] += D
print ( A [ 1 - ( B & 1 ) ] )
C += 1
while A + 1 < B :
if A + B > C :
for A in B [ C ] [ 1 ] :
A = [ 0 ] * 7
if A == '0' :
combi ( A + 1 )
A <<= 1
A , B = get ( C ) , get ( D )
if A > 30 :
A = [ 500 , 100 , 50 , 10 , 5 , 1 ]
A = B * 10000 + C * 100 + D
A . heappush ( B , ( C , D ) )
if sum ( A ) == 0 :
print ( 'OK' if A else 'NG' )
if A == 9 :
A = [ 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 ]
A %= B [ C ]
A = A + ( ( A + 1 ) >> 1 )
A , B = 1 , 2
A , B , C , D , E = input ( ) . split ( )
A = sorted ( B , key = lambda x : ( C . imag , C . real ) )
A [ B ] [ C ] = '#'
if abs ( A - 1.0 ) <= B or A <= 1.0 :
for A in range ( 20 ) :
for A in range ( 0 , 51 - B , C [ D ] ) :
A = B [ 3 ]
A = [ B + C for B in [ D for C in D if B <= C ] ]
print ( int ( 6378.1 * math . acos ( A ) + 0.5 ) )
A = B . real - C . real
A = [ 0 ] * 32
A = pay ( B )
for A in range ( 1 , 100 ) :
A = 12 * 12
while A != B [ A ] :
A = B [ C ]
A = B = 1
while A > 1 :
A = [ [ B for C in range ( 1 << D ) ] for E in range ( D ) ]
A [ B ] [ C ] [ D ] [ E ] %= 100000
print ( A . pop ( ) )
if A [ B ] > 2 :
if A == B [ C ] and D == 0 :
A [ B ] [ C ] = min ( A [ B ] [ C ] , A [ B ] [ D ] + A [ D ] [ C ] )
A . add_edge ( B , C , 1 )
for A in range ( 16 ) :
A = B [ 1 ] - B [ 0 ]
A [ B ] = A [ B - 1 ] + C [ B ]
while A < B and C < D :
A = max ( [ B [ C ] [ D ] for C in range ( E ) ] )
A [ B ] , C = D , B
A [ B - 1 ] += A [ B ] + 1
A = [ [ 0 for B in range ( 6 ) ] for C in range ( 6 ) ]
if A [ 1 ] [ B ] :
if abs ( A + 1 ) <= B :
if - A <= B and B <= A :
def cross ( a , b ) return A . real * B . imag - A . imag * B . real
while A [ B ] - A [ C ] > D :
if A [ B ] > C or D [ B ] > E or F [ B ] > G or H > I :
A = [ [ 0 for B in range ( 201 ) ] for C in range ( 201 ) ]
if A [ B ] == 0 or A [ C ] == 0 :
A [ B ] = getInt ( )
if A != [ ] and A [ 0 ] . isupper ( ) :
A = 1 - B
A , B , C = '' , 0 , len ( D )
A [ B ] [ C ] = '2'
A . append ( [ 0 , B , C ] )
A [ B + 1 ] [ C - 1 ] = A [ B ] [ C - 2 ] + D [ C - 1 ]
if A != '+' and A != '-' :
del A [ B [ 0 ] [ 0 ] ]
for A in range ( 1 , 13 ) :
if A == - 1 and B == - 1 and C == - 1 and D == - 1 :
A ^= B
A [ 0 ] [ B [ 0 ] ] = 1
if A > 10 :
A [ 0 ] = B [ 0 ] = B [ 0 ] + C [ D ]
A . append ( ( B , C , D ) )
A = [ True ] * B
if EQ ( A . imag , B . imag ) :
A = ( 31 << 9 ) + ( 5 << 5 ) + 1
A , B = C - 1 , 1
A = [ ( 0 , 0 , 0 , 0 ) ]
if A == 'END OF INPUT' :
if A >= B :
if A [ B ] [ C ] :
print ( LIS ( A ) )
A , B = min ( C ) , max ( C )
A , B = input ( ) . split ( )
A = [ [ [ B for C in range ( 4 ) ] for D in range ( E ) ] for F in range ( G ) ]
print ( judge ( sorted ( A ) , sorted ( B . items ( ) , key = lambda x : - C [ 1 ] ) ) )
A [ 2 ] = False
A , B = 0 , - 1
A [ B + C ] . append ( ( B + D , E [ D - C - 1 ] ) )
if A :
A . heappush ( B , ( C + vabs ( D [ E ] - D [ F ] ) , F , D [ F ] . real ) )
A , B , C , D , E = [ int ( input ( ) ) for F in range ( 5 ) ]
A = [ B for B in C if B < D ]
print ( 'Case ' , A + 1 , ':' , sep = '' )
for A , B in C [ D ] :
A = B [ : C // 2 ]
if A . find ( '.' ) < 0 :
while A < len ( B [ C ] ) and A < D :
A = list ( A )
A += 'L'
A = { 's' : 1 , 'w' : 2 , 'e' : 3 , 'n' : 4 }
A . append ( str ( B & 3 ) )
A -= B [ 0 ] [ 1 ]
D += 1
A = [ 0 ] * 101
A = B [ : C ]
A = max ( A , min ( B , C ) )
if A [ B ] [ 0 ] < A [ C ] [ 0 ] and A [ B ] [ 1 ] < A [ C ] [ 1 ] and D [ C ] > E :
A = math . acos ( ( B * B + C * C - D * D ) / ( 2 * B * C ) )
A = [ 'AAA' , 'AA' , 'A' , 'B' , 'C' , 'D' , 'E' , 'NA' ]
A = B * C + D * E - F * G + H * I
A [ B + 1 ] [ 0 ] = A [ B ] [ 0 ] + C [ 0 ]
A . append ( B )
print ( ( A + 1 ) >> 1 )
A += 2 * B
A = min ( B [ C ] , D - E )
A |= len ( B ) > 1
A . level = [ 0 ] * B
sieve ( )
A = [ - 1 ] * 4001
print ( 'YES' if A else 'NO' )
A . append ( B [ 1 ] )
A , B = '' , True
A = sum ( B ) - sum ( C )
A = A [ : B ] + A [ B : C ] [ : : - 1 ] + A [ C : ]
if A > 2 * B :
for A in range ( B , C + 1 ) :
A = B [ C ] [ D ] [ E ]
if A > B >> 1 :
A = '' . join ( B [ C ] )
A = sum ( list ( map ( int , input ( ) . split ( ) ) ) )
print ( A [ 0 ] [ 0 ] , A [ 1 ] [ 0 ] , A [ B - 2 ] [ 0 ] , sep = '\n' )
return int ( A )
for A in range ( 1 << B ) :
if A > 0 and B > A :
A [ B ] [ C ^ D ] += E
A [ B [ 0 ] ] , A [ B [ 1 ] ] = A [ B [ 1 ] ] , A [ B [ 0 ] ]
A . append ( B [ 0 ] )
A , B = '' , 0
if 1 in A :
A , B , C = map ( float , input ( ) . split ( ) )
A = defaultdict ( B )
A = [ '' ] * 2
if A - B [ C - 1 ] < D :
if A == 0 and B == 0 :
A . sort ( key = lambda x : ( - B [ 2 ] , B [ 3 ] , B [ 0 ] ) )
A = B + C - D
A = B * C + D * E + F * G
if A - B > 3 :
A = list ( map ( int , A . split ( ) ) )
if A == '>' :
A = 223
A = B = C = 1
A = (int) ( B * C )
if A [ B ] [ 1 ] == A [ B - 1 ] [ 1 ] :
A = ( A * A // 100 ) % 10000
A [ B - 1 - C ] [ C ] = D
A [ 1 ] = False
if A [ B ] [ 0 ] > 0 :
A = max ( - B [ C ] , D [ C ] )
A = [ ord ( B ) - C for B in A ]
A [ 41 ] , A [ 42 ] , A [ 43 ] , A [ 44 ] , A [ 45 ] = 'p' , 'q' , 'r' , 's' , 't'
A = [ [ 0 for B in range ( 5 ) ] for C in range ( 5 ) ]
A = UnionSet ( B * C )
A = B [ 11 ]
for A in range ( 997 , B , 2 ) :
print ( A [ 0 ] [ B ] , A [ 1 ] [ B ] )
if C [ A [ B ] ] == 1 :
A [ B - C ] = ( D >> ( B - C ) ) & 1
A = 10
print ( ( A + B ) << 3 )
A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ]
A , B , C = 3 , 3 , D - 2
A [ B ] [ 0 ] = C
A += B [ C ] - B [ D + 1 ]
A [ B ] [ C ] [ D ] [ E ] += A [ B - 1 ] [ C ] [ D ] [ D ]
if A [ B - C ] == 0 :
A , B , C = list ( map ( int , D . split ( ) ) )
A -= 5 * B
A . append ( float ( input ( ) ) )
if A [ B ] == 'a' :
return - 1 if A > 0 else B
while A > B and cross ( C [ A - 1 ] - C [ A - 2 ] , D [ E ] - C [ A - 1 ] ) < 0 :
A = { }
A , B = dijkstra ( C , D , 0 )
A = len ( B ) - 2
print ( A [ 0 ] [ 0 ] , A [ 0 ] [ 1 ] )
A //= 100
A [ B - 1 ] . append ( C - 1 )
A , B , C = D [ 0 ] , D [ 1 ] , E [ 0 ]
A = B - 2 * A
A = dict ( sorted ( A . items ( ) ) )
print ( (int) ( A ** 2 / 19.6 ) // 5 + 2 )
if A < B [ C ] [ 1 ] or B [ C ] [ 0 ] < A :
A [ B ] = False
print ( A * B [ C ] )
A = 500
A = ( B + C ) >> 1
A += B . power [ C ] + B . weight ( C )
if A [ B ] [ C ] + D >= A [ B ] [ E ] :
A , B = C [ D ] , E [ D ]
combi ( 2 , A , B [ C ] [ 2 ] )
if A + 1 < B and C [ A : A + 2 ] == 'IO' :
A = [ 380 , 550 , 850 ]
A = bisect_left ( B , C , 0 ) - 1
A , B , C = D
A += 1
A = B [ C [ D ] ]
A %= B
A = [ [ ] for B in range ( 45 ) ]
A = [ 1 , 5 , 25 , 125 , 625 , 3125 , 15625 , 78125 ]
A = [ 0 ] + [ int ( input ( ) ) for B in range ( C - 1 ) ] + [ D ]
if A == 2 :
if A [ B ] - A [ B - 1 ] >= C :
A = [ [ B for B in range ( 7 ) ] for C in range ( 2 ) ]
A = [ [ '' ] for B in range ( 1002 ) ]
if ( A & 1 ) == 1 :
parse ( A , B [ C ] [ 1 ] )
A = str ( int ( B ) - int ( C ) ) . zfill ( 4 )
A = ( B >> ( C * 3 ) ) & 7
if A [ B ] [ 1 ] :
A //= - 10
A , B = gcd ( C , D ) , gcd ( E , D )
if A [ B ] [ C - 2 ] == '#' or A [ B ] [ C - 1 ] == '#' or A [ B - 1 ] [ C - 1 ] == '#' :
if ( A | B | C | D | E | F ) == 0 :
A = ( B . real - C . real ) / 2
A = sum ( [ int ( input ( ) ) for B in range ( 4 ) ] )
E = F - A
if A in B and B [ A ] + C == 0 :
for A in range ( B , C ) :
A [ F ( 't' ) + F ( 'h' ) + F ( 'a' ) + F ( 't' ) ] = ( B , C )
if A [ B ] >= 0 :
A = ( - 1 , 0 , 1 , 0 )
A , B , C = D [ 0 ]
A , B , C = ord ( D ) - ord ( 'A' ) , ord ( E ) - ord ( 'A' ) , ord ( F ) - ord ( 'A' )
A = ( ( B [ C ] + D [ C ] ) << 2 ) + ( E [ C ] << 3 ) + E [ C ]
for A in range ( B [ C ] [ 1 ] , - 1 , - 1 ) :
A [ B ] [ 1 ] = C
def EQ ( a , b ) return abs ( B - C ) < A
A = B + 5
A = [ B ] * ( C + 2 )
A [ 1 - ( B & 1 ) ] += str ( C ) + A [ B & 1 ] [ D - 1 ]
A , B = [ 0 ] * 120 , 0
for A in range ( B ) :
A = B . id [ A ]
A  3 1  B     50        
- A  B   B  A   
B  C    D    E  C           A   
B  ' + '     0   1  A 
 
un it e ( A * 12 + B , C * 12 + D )
to po log ical _ s ort ( A , B )   1   0 
E Q ( A [ B ] . im ag , 4 )  E Q ( A [ C ] . im ag , 4 )   
( 0 )    B      A  1   
B  1      0    -1         A   
C   B  C      A  B 
C  A  B  1       A  B   
B  2       B  3         A 
B  C   B  D      100       C  D      100       A 
                   A  B 
1  A 
A   B       0   
A  1    
b is ect _ left ( B , B [ C ]- B [ D ] )  1     A 
     A  B   
A  2     B  2     
A  0  D         C   B  C  18           
0  10          A   
C  A  w s  B   
  ' Data  '  A  1    ' : ' 
( 0 )    10      A 
ch ec k ( A , B [ C ] [ 1 ] )
A  ' app le '  ' _ __ __ '     A 
( ( 0  1 )    ( 1  0 )    ( 0  -1 )    ( -1  0 )   )    A 
                   A  B  C  D 
  B  C       A   
A  B  C    4     
  A 
A  B    A  C  D  1           
B  C   2     A 
      A  B 
A     A  
B                 A 
A  B  C        
A  B  C  D    E    
key  x    ( - B   x  1   )     A   
A  12   
c al c ()     A  B 
A  B  C  D 
C        A  B   
( B )    2      A 
B  C  1        A 
C                   A  B 
pre v _ per m u t ation ( A )   
A          
b is ect _ left ( B , C , 0 , D )  A 
A  p ar  B    0    
0  G  1           F   0  D  1           E   0  D  1           C   B        A 
0    A  B 
A  D  C    A  B  C   
C    A   A  B          
A  6 1     20      1     
A  5    
( ( 0  1  2  3  4  5  6 )    ( 0  2  6  3  4  1  5 )    ( 0  4  2  1  6  5  3 )    ( 0  3  2  6  1  5  4 )    ( 0  5  1  3  4  6  2 )   )    A 
0  C 
C . p op left ()     A  B 
math . factorial ( int ( in put () ) ) 
( ( 0 ,  ' IDE N T IC AL ' )  ( 1,  ' CL OS E ' )  ( 2 ,  ' D IF F E RE N T ' ) )    A 
A    
B  C    2   -2  A 
d i j k st ra ( B , C , D )  A 
0  3 1  A  B 
re c ( 0 , 0 )
E  A  B  2  C       1      D      B       
1  B  C   
A  3  
A     B     C      
- B  C  D        E  C  D        A 
C  B   A 
0  -1  0  A  B  C 
A  B     B  A    ' ] '        
0  A  1   
C  A   ' A '     B      
re c ( A + 1, B - C , C )
10  B    A 
A  B    C  B        C      
B  C       C  C  1       2         A 
( 0 )    20 2      ( 0 )    20 2      A  B 
in s ort _ left ( A , B )
A  B  C  1        D    
A  B    C  D       
[MASK]  0     
A  B  C       A 
B  1   
C   A       C   B       A  B 
A  0      B  0      C  0      
A  ' R '     
       A  B  C 
A  B    ' a '   A  B    ' z '   
A  B  C    D    
1  A  A  1       2       
A  2  B         
B  ' X '  C       A 
0  8         B        A 
A  B     
A  60  B  C        B  C  1         
0  0  A  B 
A  B  C  D  E    A  B  C  1      D  D     
A  B  C      D     
A  ' { : d } . { : 0 2 d } ' . form at ( B / / 100 , B % 100 ) 
         A  B  C 
17  [MASK]      3  D  3             19   A  B  C    1   
( 0 )    B      A  it er 
           float       A  B  C  D 
A     A    
                ( -1 )     A 
D     A  B  C   
0  5  B               A   
A  B    ' [ '     
A       
C                  A  B 
A  
A  1     B  1     
A  ' ) '   
set con text ( C on text ( pre c = A , r ound ing = B ) )
A  B  1    C  1      A  B  C    D  B    E  C            A  B  1    C  1     
A  s ize  B    A  s ize  C     
A  ' X '     
D  A  B  C   
A  p ar  B    A  p ar  C      
E  A  B  C  D   
2  [MASK]     A 
A  B  1        C   A  B   
A  1    c ro s s ( B [ A -1 ]- B [ A -2 ] , C [ D ]- B [ A -1 ] )  0       
A  3  B        
A  B   C  A    0     
( ( ' I ' , 1 )  ( ' V ' , 5 )  ( ' X ' , 10 )  ( ' L ' ,  50 )  ( ' C ' ,  100 )  ( ' D ' ,  500 )  ( ' M ' ,  1000 ) )    A 
A     ( B  C  C  B     )   
C  D  E     F        G  D  E     F        A  B 
A  B  C       ( B  D    E  C  D      1       )   
      A  B 
A  p ow er  B    C   
2  B    2         A   
0  B    2         A   
B  A  C      A 
(  )    100      A 
A  B       
A  B    C  D      
A  1     
0  8         C   0  5         B         A 
A  B  C  re al  B  C  1    re al     B  C  im ag  B  C  1    im ag         
A  1   
0               A   
0  A  B    0   
C  ' + '           A  B 
B  C      C  D        A 
key  x    ( x  1    x  )     A   
A  2   
A  B  2    C    
B  1    2  C      1            A   
1  A  B         
C   B 
A 
B   ' [ 0 - 9 ] + '           A   
A  0   B  A    B  A  1          
( 0  1  0  -1 )    A 
A  0   -1   1 
C  0  A  B 
 A  B       
A  B  2      ' [ '     
d 2 t ( C [ D ] )  d 2 t ( C [ D + 1 ] )  A  B 
0  2         D   0  C  2           B   0      A 
A       A     0 
A   1    A  0    ' _ '     
A  B    A  B     C  D    
F     A  B  C  D  E   
A   4     A  B   
C      C     A  B 
f act or ( B + 1 )     A  B 
0  0  0  A  B  C 
A  B    1   
0  C  1           B   A     B   
0.0 17 4 5 32 9 25 1994 32 9 5 7 6 9 2 36 90 7 68 4 89  A 
0  B     5         A   
C  1     D      1    E  1     F      1   A  B 
A  10    B  C    3    
3 1 
A  B  1       A  B  1         
pars e ( A , B [ C ] [ 0 ] )
A . he ap push ( B , ( ( - C < < D )| E , E , C ) )
A  B  C    0     
A  1   
A  1   B    C  D  A    C  D  A  1         
A  0    ' 0 '     
1  A  B   
A  B  C      
A + A / / 4  A / / 100     A  400       13 * B  8   5       C   7      
( 0 )    3      A 
D  D  A  B  C    A  C  B   
0  20         D   0  16         C   0      0  A  B 
d i j k st ra ( B , C , D , E , F )  A 
A    1     
A  20    
A  B    A  B  1        
A  D  E    F   A  B  C   
           float       A  B 
1.0  A  1   
A  B    ' Y '     
( 1  5  10  50  100  500 )    A 
A  0   A   A  B  C        
0  1000          A   
0  4 5         C   0  4 5         B   0      A 
A    B    C    A  B  C 
A  ed ge  B     ( C  D  E )   
A  B  C  1           
0  E         D   0  C         B   0.0      A 
0 x 7 ff ff ff ff ff ff ff  A 
b is ect or ( B [ C ] , B [ D ] )  A 
x    x  1       B           A 
A  3   
- A  B     A    
A  B  1      D  C    A  B  C  7  D       
[MASK]  
A  B    A  C     
A   A 
  ' = '           A  B 
A  B  3       
  A 
A  1      B  1   A  B 
A  2       B  B         A 
A  1     5      1     
30  C      D  2       2       6  D      2      A  B 
                    A 
B  2   C  2    0.5   A 
c al c ( A , B , C , D , 0 )  0    E     
E            A  B  C  D 
           A 
A  B  C    A  B  1      D    E  D  C          A  B  C   
1  A     A 
9  -1    -1         A   
A  ed ge  B  C  1    D   
0  100 1  B              A   
b is ect _ right ( B , C [ 2 ] , D )  A 
A  0   A  B    C  0   C  B    D  A  C    E     
 
B    A 
0  C         B         A 
A  B    C    C  A  B  1       
B  C  18        A 
A  B    A  B  1           C    
A  1   B    C  A  D    C  A  1    D       
A  0    ' , '      
b is ect  
A  B    0    
b is ect _ right ( B , int ( C [ 2 ] ) , D )  A 
0  5         B          A 
     2      A 
( 0 )    10 5      A 
A  B   
A  1      B     
A  0    B  0    
A  0    B  A     
A  B   
A          B 
' D '  A 
A  B  1      C  1       
B  C    D     A 
0  C  2           D   0  C  2           B   0      A 
B   1    A 
A  B  C    40   17 30  D   D  19 30   17 30  E   E  19 30   
A  0    B  c ro s s ( C , D [ 0 ]- A [ 0 ] )  c ro s s ( C , B )          
0  ( 0 )    100 2      A  B 
A  0     B   A 
A     ( B  C  0  D )   
    
( 0 )    6      A 
A  B  C    B  D  1            1       
A  B      3. 30 5 78 5     
B  C  1    100 80   B  C  1    100 80       0  A 
A  B   
0  C  1           B   B    A 
A         
A     A     B    C     
A     B  2       B  3        
19  -1    -1         A   
( -1 )    A  V      A  l evel 
( ( 0  -1 )    ( -1  0 )    ( 0  1 )    ( 1  0 )   )    A 
c al c ( in put () ) 
0  300 01         B   0    A 
x    ( - C  2    x  3    x  1   )       B         A   
2  A  B   
A  B    10    
A  B    0    
C . he app op ( D )     A  B 
B  C     B  C         D  E     D  E           A 
A  B  C      1        0    
B  ' + '     A  C     A  C      A 
 B  ' o '     A 
A     B      B  1        
A  B      B 
A  100 0000    
             A  B  C  D 
A             
A  B  1        
A  B  1        C   C    C   A  B  1        C   A  B   
B  C  1    D  C        B  C  2     A 
A  16 5    
C  D    C  D  1    A  B 
A  B   A   B 
A  B  1  [MASK]      1     
E Q ( A [ B ] . re al , 0 )   
n l c m ( B , C )  A 
                 A 
re c ( 0 , 0 , 0 )
B  it er  C    B  ed ge  C            A   
A  B   A  C   
math . h y p ot ( A . re al - B . re al , A . im ag - B . im ag ) 
B  B      C  C         2  B      C      math . co s ( D - math . f abs ( E ) )             A 
( ( 1  4 )    ( 0  2  5 )    ( 1  3  6 )    ( 2  7 )    ( 0  5 )    ( 1  4  6 )    ( 2  5  7 )    ( 3  6 )   )    A 
1  11          A   
          A 
s am e ( A , B )   
A  B  C  1      8     
0  E  D  C  B      A 
1  C   A  B     
A  4   ' Y E S '   ' N O ' 
1  1  0  A  B  C 
A  0    B  l evel  C    B  l evel  D      
A  B  C      
A   B     
A  B  1        C         
( B  0    ( B  1     )     0  C         B       )    A 
A  B  1        math . at an ( 1 / C [ B -1 ] )   A  B   
A  B     ( C  D  E )   
A  1    A  2     0     
B  C  1    A 
( 0 )    27      ( 0 )    27      A  B 
ro ot ( C )  ro ot ( D )  A  B 
in it ( 12 * 12 )
A         1   
B  C  D    A 
 A  B      C   D       E    
C     A  B 
C  -1  A  B 
1 e - 7  A 
B  1      -1    -1         A   
A  B    C       D  E    F           
( 0 )    B      A 
A  4       0     A  100       0      A  400       0     
1    A   
A  B  4       
A  1      B  1     A  B 
B        A   ' { } : { : 0 2 } ' . form at ( * A )      
2  A      2   B    ' O K '   ' NA ' 
C  1    C  2    A  B 
B  B  1         1      A 
A  7  B        
     1   A 
2  3  A   A  1   
1    
A  B  C  1      D           A 
A  B  C    D . ro ot ( id ( B , C ) )  B  C        
0  100         B        A 
   A 
' Hello  World ' 
A  B  1    C  D      A  B  C     
key  x    ( - B  1    x  )     A   
c ro s s Point LL ( B , C )  A 
A  B    C  D  E      
A  B  C          1   
A  B    C  D     E    
B  2   300          A   
re  
( 0 )    3 1         A  B 
    A 
A     B  C   
B  1      C  2        -1         A   
' A ' 
B  60      C   A 
5  0    -1        B   A     B   
0  C         B        A 
A  B  1    C  1        1   
3  B  4        B  100         B  400       A 
1  A  1  B   
A  ' R '   
g c d ( A , B [ C ] )  A 
A  1 60   B  25   
1000          A 
A  w s  B    A  w s  A  p ar  B       
B  1      C           A   
0 
1  B  C  1      D  1        B  C  D  1        B  C  1      D      A 
' f '  ' g '  ' h '  ' i '  ' j '  A  21    A  22    A  23    A  24    A  25   
A  B       C  D        
do t ( B [ 1 ]- B [ 0 ] , C [ 1 ]- C [ 0 ] )  A 
A  B    C  B    ' J '       A  B  1     
A  2    
A  B  C      1   
A    A 
A     ( B     B  1    B  2    B  3    B  4   )   
( A  B  1   )   
B  9      C  18        A 
A  B  1      C    D    
A  B  C        A  C    D      
A  B  1    1   
                  A  B  C  D  E 
A  1      C  1     A  B 
B  im ag  C  im ag     A 
( 0 )    C      ( 0 )    C      A  B 
A      
A  600    A        B   A  B  2           
A . b f s ( B )
A  ' = '     
0  B  C     1            A   
3  11          A   
B  C  1      A 
  ' , '                 A  B  C  D 
(   A )   
next _ per m u t ation ( A )   
A  B    C     1   0 
A  B    ' - '     C  A  B  1      ' 0 '   A  B  1      ' 9 '   
14 40  B      C  60        D   100 80       A 
D  E    A 
A  B    1     
A  0   B  0   
-1  A 
  A  D    A  C      A  B   
A  10    B  C  A      B  D  A      
B  C  im ag  D  im ag     100         A 
B   B  p ar  C         A 
B  C    D      E  F  C         A 
0  C         B   in put ()                      A 
A  B  C       
A  B  C    D      
A  B  C  D  E      
E . he app op ( F )     A  B  C  D 
B  C        A 
A       
( A  B )   
[MASK]   
B     A 
factorial ( A )  factorial ( A - B )      factorial ( B )     
1000  A 
( ' l un ch '  ' d in n er '  ' m id n ight ' )    A 
A    B    A  B 
0  C         B                  A 
( ' pre - me i j i '  ' me i j i '  ' ta is ho '  ' sh ow a '  ' he is e i ' )    A 
A  B   A  C  60          A  C  1   60        A 
B  C  2            A 
B           A   
A  B    ' = '     
A  B  C    2     
c ro s s ( B - C , D [ 0 ]- C )  A 
A  B    1   
A  B  C      1     
re   
0    0  0  A  B  C  D 
D  A  B  C  1      B       
math  
1 e - 5  A 
( 0 )    B  C  D      1        A 
A      
A     B  C   
D        A  B  C 
           float        A  B  C  D 
C  D       E  A  B 
B  C    C  4             A 
c ir c um s c r i b ed _ c ir c le ( B , C , D )  A 
A  0    ' E '     
A   B  1      1     
d i j k st ra ( A , B , C , D ) 
A  0     
B  10       A 
( B )    C  1        A 
A  ' A '     
0  D         C   0  2         B   0      A 
0  D         C   0  3         B   0      A 
C   1      C  1    A  B 
W e ight ed U n ion S et ( B + 1 )  A 
A  ' L '     
B  1      A 
B  C    D      E  C    F       A 
A  B    A  C      
A  B     ( C  D )   
2  18          A   
A . un it e ( B , C , D )
100  A        100  B        100  C        A  B  C 
A  0    A  3   B  0    B  3   3  A      B   C     
A  B  1    C    1   
A  
B  C  D  3              E  F  1          3         A 
B  1    A 
A  B  C    0    0   
A  B    9    3      C     3     A  3  B       3 * B  3       C     3     
D  E  A  B    C  B   
pr im e _ f act or ( B )  A 
( 0 )    E      ( 0 )    E      ( 0 )    E      ( 0 )    E      A  B  C  D 
A  re al  B  re al      A  im ag  B  im ag       
A  B  1     
0  4         C   0  4         B   0      A 
A  B      
A  1    B  1   A  B 
A  B  100       
0  7         E   A  B  C  D    E      A 
A     B  2       A 
( 0 )    7      ( 0 )    7      A  B 
B  2    A 
A  B  C    ' * '     
32 77 0  A 
B  1      C  1        -1         A   
( 600  800  1000  1 200  1 400  1 600 )    A 
B  C  100     2      A 
A       A 
B  C  2    0    c al c ( B [ C ] [ 2 ] )   1  A 
0  3  A  B 
  B   A  B 
B  C       D     A 
B  C       A 
( 0 )    1 28      ( 0 )    1 28      A  B 
A  B  1      C  1        1   
C     B 
d i j k st ra ( A , B , C , D )
(  )    B      A 
10  A      B  C     A 
  D  E  A  B  C 
C  D  E      F  G  E     A  B 
  A   
 A   re al  B   ' . 3 f '       A   im ag  B   ' . 3 f '       A  1    B   ' . 3 f '     
p al in d ro me ( B , C )  A 
  A 
A  B   
A  B  C  D  E      1              
A    B     C       
A    
B  1      1    -1         A   
A  B  2       
A . he ap push ( B , ( 0 , C ) )
A  B   C   B  C   A   C  A   B   
0  C  D  E    A  B 
( ' S un d ay '  ' M on d ay '  ' T u es d ay '  ' W ed ne s d ay '  ' T h ur s d ay '  ' F r id ay '  ' S at ur d ay ' )    A 
1  C  1           B   B    A 
( -1 )    B      A  p ar 
A  0    ' # '     
A  B     ' NA '   A 
B  C  D    A 
A  2  B        
A  B  C     
A  B   1        C   
   
    
D  1    D  2    D  3    A  B  C 
D  0    -1   C  D     A  B  C   
    
1 e - 11  A 
to po log ical _ s ort ( A , B )
A  2   
0  B  1   A  B 
A  2     
 P P e Q  a  b     
A  0    
B  C  2    D      E     B  C     A 
B  0    C      B  1        A 
A  1    B  1   
A  B   C    
B  100      C   A 
    ( 0 )    1  A  B  C  D 
re c ( 0 , A , A )
11 50  A 
B  C  A   A  1   
1  B   A  2   
A     1  6 2      
A  B  C    B  D         A 
A  B    C   
0  C         D   0  C         B   -1      A 
0  8          A   
C  2      1    C  2      A  B 
1  7          A   
[MASK]  B  1  A  1             
B . C o un ter ( C )  A 
D  E     A  B  C   
A  B     C  1     
A  B  C  3      C  3        
( B )    C      A 
A  B  C     
(  )    7      A 
' A '     A 
A  B  1      C  D    E    
0  C  D   A  B 
0  D         E   0  D         C   B      A 
A                    
A  re al    B    A  im ag    B    
[MASK]   ' no '   ' y es ' 
A  B  1        
A  B  1      2   1       A  B   
0  6          A   
1  A   2   
C  B 
A  0         
2  B           A   
A  B      C  1       D   1         
C  0       A  B 
2           A 
A  B -2  C    ' # '     A  B -1  C    ' # '     A  B  1      C  1      ' # '     
A  B  C     
A  B    C      
- D  E    - D  E      F  1      A  B  C 
0  11 11         B   B  3     A 
B  0      A 
B  B  1       B  2       6      A 
A  ' # '     
A  B      C    
( 2 )    A 
A  B    ' " '     
(1)    5      A 
A  B    C      200  B        300  C          
A [ B ] [ C ]  D  D    A [ B ] [ C ]  E  E     10 0000      
A . he app op ( B )
0  C  1           C   0  B  1           B   0      A 
A   ' Y es '   ' N o ' 
3.1 4 15 9 26 5 3 5 89 79 32 38 4 6 2 64 3 38 32 79 5  A 
A  0    B  l evel  C    0    
ter m ()     A  B 
A  B  C  D  E           A 
A  B    C    A  B   
( C  D  2         )    A  B   
A    
B  C      0.5     A 
A  B  1    0    
( -1 )    B      A 
C  1    C  2    A  B 
A  ' D '     
2  B  1     A 
con ve x _ c u t ( B , A )  A 
0  10 1          A   
A > = 0  A < 5  B  0   B  5    C  0   C  5    
A  B  1    C    1     
B   B  5         B  3    B  2           A 
A  B         
B  C  D     E  F       A 
B  1   C     D  0     D  B  1      A 
A  B  C    ' 0 '   A  B  C    ' 9 '   
0  2         E   0  5         D   0  5         C   0  5         B   0          A 
( B  C )    A  F ( ' t ' )  F ( ' h ' )   F ( ' i ' )   F ( ' s ' )     
 
A  B  C  D      
A   0       
(1)    2  B      1        A 
' { : 0 2 d } : { : 0 2 d } : { : 0 2 d } ' . form at ( A / /3 600 , ( A % 3 600 ) / / 60 , A % 60 ) 
A  B  C   C  B     B   
  ' , '                 A  B  C 
A  p ar  B    A  p ar  C     
A  ' ( '   
( 0 )    C      0  A  B 
A   B       
m o ve ( A [ B ] [ C ] )
U n ion S et ( B + 1 )  A 
0  1       A  B   C  0   
( 0 )    C  1        0  A  B 
A  B    A  0   
A  B      
2 40  B      A 
A      A 
1 
B  1   A 
B  C  1    D  E  1          A 
- C  D    A  B    E  F     A  B   
( ( -1  0 )    ( 0  1 )    ( 1  0 )    ( 0  -1 )   )    A 
A  0    A  4   B  0    B  4   C  B  A   
A  B    A  C   
A  3   B       
(  )    B      A 
A  B    C  D       
B   A 
B         A   
0  B     4         A   
' null ' 
0  13          A   
5  B  1        -1         A   
A  1    B  C    1   A  B  C   
A  B        
( 1  A  w s  B    A  w s  C       )   
A  B  1         C   ' N O C OL OR ' 
D . he app op ( E )     A  B  C 
A  B  C      D  E  C      
B  0     B  2      A 
( 0 )    12      ( 0 )    12      A  B 
A         A                 
0  1 0000 0000 0.0  A  B 
A  0    B  0    A  0    B  0    
A  10    
A  B  C  D  D    A  B  C  1      D  D    A  B  C  1      E  D       
0  2 10         C   0  3         B   0      A 
A  A  1     5          A 
A  A  5      100       A 
A   B         
B  B      C  C        0.5   A 
A . he ap push ( B , ( 0 , C , 0 ) )
A  ' H os hi no '  ' H o sh in a '     
7 200  3 600  B      60  C        D      A 
A  C      B  C      A  B 
A  B       
2  B          A   
A  3        
   ' [ . ,  ] '      A 
A  B  A        
A  B    C  A             
A  B    C  A           
is O r th o g onal LL ( [ A , B ] , [ C , D ] )   ' Y E S '   ' N O ' 
     A  B    math . co s ( C [ B ] )       A  B    math . s in ( C [ B ] )      
A  B     B  A    C        
A  B  2     
    A 
A  w s  B   
A  B  0           
B  1    A 
( ( 1  2  4  8 )    ( 4  8  1  2 )    ( 8  1  2  4 )    ( 2  4  8  1 )   )    A 
A  B  C    ' . '      
                   A  B  C 
con ve x _ h ul l ( B )  A 
A  B  C  1    D  1      E  D  1      E  C        A  B -1  F  C      A  B  C  1    D  1     
(  )    B  1        A 
A  0    B  C       
A       A        1       
( 2 )    B  1        A 
( C      )    A  B   
is _ at S am e S ide ( A , B , [ C , D ] )
ch ec k ( A , B )   
( 0 )    26      A 
B  6       B  7         A 
f act or ( B )     A  B 
A  g c d ( A , B )      B     
0  A  ( 0  1  2  3  4  5  6  7 )     
15  A 
A  ' x y '     
- get In t ()  A  B   
0  C         B       A 
1 
A  B  C    A  1             
swap ( B , C , D )  A 
A  [MASK]  C    A  [MASK]  C  1           
A  B    C  B       
A  1     A  6     ' Open '   ' C lo se ' 
( 0 )    ( 0 )    ( 0 )    A  B  C 
A  c al c ( B )  1     A 
A  B    
com b i ( A , 20 )
25  A 
A  B  C    1     
A  B  1    C  1      1   
A  B      C     D  2         
B  6   A 
( 0 )    60      A 
A  2    
0  B   2             C   B  C    C  3         A 
7 20  B     A 
B  C     A 
A  0    1     
A  2    2     
A  A . group (1)  A . group ( 2 )     
( ' A '  ' B '  ' A B '  ' O ' )    A 
B  B       C    B         A   
               A  B  C 
A . he ap push ( B , ( - C , D ) )
A  B  C 
10 0000 4  A 
B  A 
A  B     1    C  D     1   
( 0.0 )    2      A 
500 25  A 
1  A  A            
  ' , '                A  B  C 
A  0    ' FOR W AR D '     
( 0 )    100 2      ( 0 )    100 2      ( 0 )    100 2      ( 0 )    100 2      A  B  C  D 
A  B  C    ' c '     
A  B  3       C  1      A  B / /3  C    D [ B / /3 ] [ B % 3 ]  E [ 0 ] [ C ]  E [ 1 ]  C       1     A  B  3       C  1     
 v abs  a     
2  B  1            A   
A  B    A   ' Imp os si ble ' 
A  B    A  B  1        1        
0  10 1         C   0  3         B   0      A 
B  D ec im al ( C )     A 
A  0    -1   A  B  C        
0  2         C   0  4         B   0      A 
A  B  C    3       
b is ect _ left ( B , int ( C [ 1 ] ) )  A 
A  B    A  B  2       
B   A 
A  B        ' O K '   ' N G ' 
B     A 
A     80   
b is ect _ left ( A , B ) 
( 0 )    1 0000 3      ( 0 )    1 0000 3      A  B 
C  D    1  A  B 
0  C         B   -1    A 
A  B  5      
A  B    100 0000   
x    x  1         B           A 
C  1   A  B  C  1       
A  2    
A  0    ' ST OP '     
( 0 )    3 1      A 
( -1  0  1  0 )    A 
' z '  ' . '  ' ? '  ' ! '     A  6 1    A  6 2    A  6 3    A  64    A  6 5   
A  1   
A  B  C    B  D       A 
B . b is ect _ left ( C , D )  A 
3 600  B      60  C        D    3 600  E      60  F        G      A 
0  C  B    A 
  A  1    ' : '  ' * '  B  A        
0  C         B          A 
( ( -1  0 )    ( 0  1 )    ( 1  0 )    ( 0  -1 )   )    A 
A  1      A  B 
B . b is ect _ left ( C , D > > 1, 0 , E )  A 
A  25 5    
A  ' 0 '      
A     B  C  D           E  C  F             
( 0  1  2  4  6  16  12  64  24  36  4 8  10 24  60 )    A 
B  C   A 
d i j k st ra ( B , C , 0 )  A 
1      
A  B    C   A  B    A  D      
A  B    ' 0 '   A  B    ' 9 '   
0  B            A   
32 3  A 
B  2    B  4         B  5    B  1           A 
P P e Q ( A , 0 )   
C   C   A  B 
6  -1    -1         A   
B  C  D  E  F  G       A 
B  ' & '       A 
  ' , '                A  B 
A   
key  x    ( x   x  1   )     A   
A  0     B  A    0   
0  7         B   B    A 
com b i ( A + 1, B , C + D [ E ] [ 2 ] )
C  D    A  B   
          A  B 
A  0  D         C   B  C      
0  26  3              A   
A     B  C   D      
3  A     A 
( 0 )    B      A  p ow er 
B  C    D          A 
S t ack ()  A 
1  A  re   
s y s  std in     A   
C     A  B   
A  B  C  1        
A  B  1        0     
A  B    A  C  1         D    
( 0 )    3 0000 5      A 
0  F  1           E   0  D  1           C   B      A 
( 0  9  26  50  80  1 15  15 4  196  2 40  28 5  3 30 )    A 
  A     B  2   
0  3         E   0  D  2           C   B      A 
A  1   B    
A     ( B  C )   
1  8    2         A   
C     D       A  B   
0  3          A   
' X '  ' Y '  ' Z '  A  ' A '    A  ' B '    A  ' C '   
  A  B        
C  D    E  F    A  B 
A  [MASK]  C   
A  0  D         C   B  C  9           
B  C    D   A 
A  0   
B  C    1     A 
A  id  A  id  B      A  id  B   
A    1     A    3     
0  C         B             A 
1  2  B          2         A   
A  B    math . s in ( C * D )  math . co s ( C * D )        
  A 
' u '  ' v '  ' w '  ' x '  ' y '  A  5 1    A  5 2    A  5 3    A  5 4    A  5 5   
A  B       0     
0  G  1           F   0  E  1           D   0  2         C   0  2         B   0          A 
A  B    C  D   E  C    0     
C  1   A  B   
A  B    C       A  B  1      C         
B  C  D       A 
A  1    A        B   
A  4   
B   C    A 
B          A 
A  B     8   
A  B  id  A           
( 0 )    100 1      A 
1  16          A   
key  A  [MASK]     A     key  B  A    
0  2         C   0  21         B   0      A 
b is ect _ left ( B , C [ 1 ] )  A 
A  B    ' @ '     
A  B    re 
A         
100 3  A 
A  re al  B  im ag       A  im ag  B  re al        
A  6     
A  B  1     C          
A  B  1      1   
B  C  D    E   B  F  G     A 
A  19    
A  2   
A  B    ' 1 '     
A     ( B  C )   
B  2     A 
( 1  2  1  0 )    A 
A            
B  11          A   
1 0000  A 
        A                  A               
in put () . s pl it ()    int        A  1         
A  B  C  D  D    A  B -1  C  D  D    A  B -1  C  E  D       
1  ( 0 )    C      A  B 
2 2.0  A 
C  D  E  1           F  D  E  1      1       A  B 
B  C  D  1     E   0  A 
A  B    0     C  D  B      
C  A  B     A  B  1     
A  B       
A  B  2      C    1   
A  ' , '   
A  B  0    0     
A  1  B    
  A  1   
A  3     
A  B  1       
B . ro ot ( C )  A 
      A  B 
A  B    C    
B  C  A  B 
A  B    C  A           
c al c ( A ) 
3  4  1  A  B  C 
1  B          A   
c al c ()  A 
A  B    C  B      
A  B    C  D        
A  B  4  C           
B  C      B          A   
B     C     A 
0  2          A   
0  B  C              A   
A  B  2    C    1   
    A   B   
( 0 )    B  1        A 
A  B     
                 A 
A  B    C  B     A  B  1     
A  B 
1  A   0   
A  B    C  B     C      
' O K ' 
A   
A  B  C    D    A  B  C    1     ' NA ' 
0  2         C             A  B 
B  C      A 
A  B      A  C     
A  B    C  B   20   
D ec im al (1)  A 
( C )    D      ( 0 )    D      A  B 
A  0    ' . '     
50  A 
C  D  B     ' a '        E      A  B   
A   B  2      
A   B  1        
A  0    ' i '     
f act or ( 0 )  0    2     
de que ()  A 
' L '  A 
A  B  C    D     
0  26          A   
A      
B  21          A   
4  B      B      C  C            C   A 
A  B    2      A  B   
A  B  C  2      ' # '     A  B  C  1      ' # '     A  B  1    C  1      ' # '     
A  B    A  C  B        D      
A  B  C  D    D    1     
d 2 t ( A )  d 2 t ( B )  A  B 
( 4  1  4  1  2  1  2  1  4  1  4  1  2  1  2  1 )    A 
( 0 )    1 0000 5      ( 0 )    1 0000 5      A  B 
1  B  1      1  [MASK]           A   
A   B  1      -1      A  B         
5 0000  A 
A  B    ' O '     
( 1  2  4  8  16  32  64  1 28  25 6  5 12 )    A 
1  0  D  A  B  C 
A  B              
A     ( B  C  0 )   
A  0    B  A   1     ' NA ' 
B  4       B  5         A 
A  B     0     
B  C    D       A 
s y s  
0  2         D   0  C         B   0      A 
A  0    ' - '     
x    ( - C  2    x  1   )       B         A   
A  B  C       
  ' C as e  '  A  ' : ' 
           float        A  B 
B  C  D        A 
' Y es ' 
B  2      -1    -1         A   
C  1      B   A 
0    
A  0     1   A 
A . max F l ow ( B - 1, C -1 ) 
A   A  0    B     
C   D  A  B 
A  0    0    A  1    0       
B  2   4  C      D         A 
A  0    ' ( '     
A  B        C  D        
B   5    A 
A  ' D '   
A  99    0        
B  C       A 
( 0 )    8      ( 0 )    8      A  B 
A  0   B  0   A  9   B  9   C  D  A  B   
( 0 )    12 6      A 
B  1    A 
com b i ( A , B -2 )   
A   B       A  C    D        A  E    C        A  B    E        A  D           A 
A  0    A  B   C  0    C  D   
A . ro ot ( B )  B     
10 0000  A 
key  x    ( B    x  )     A   
B  C  1  A  B  C 
A  B    C     
B  C  D  E         A 
A  0    0     
' ( J * ) ( O * ) ( I * ) '  A 
A  B    
A  B  C        
0  5 1         C   0  5 1         B   0      A 
A  B  C       D       
B  C  0    D  C        A 
A     ( B  C  3  D        E     )   
A  B  C    B  D  1         E  D          
push B ack ( A + B , A + C )
-1  2          A   
A  ' H IT '     
( A  d ist ( A , B ) )   
A  B    C  A    C  A  1        1          
A  B  C   D   E      1   
   C   A  B 
A  1   
A  3   
0  A   0   
C  D    1      C  D  1      1     A  B 
100  A 
                 A 
B  10          A   
A  re al  A  im ag 
A  B      0    
25 0000  A 
A  - B    
  ' , '         float       A  B 
A  c al c ( B > > 1, C > > 1 )  
0  4 7          A   
B  5          A   
A  0   B  A    B  A  1          
100 1  A 
B  ' | '        A 
' L O OP ' 
A  60   
    
0  1  A  B 
A  60    
A  B    C       D    
0  90  D       0  A  B  C 
A  B   B  C   D  E   E  F   
     A  math . co s ( B )        A  math . s in ( B )       
( 0 )    4      A 
he ap q  
' U '  A 
0  4          A   
A  C    A  B    A  B    A  C   
A [ 0 ]  re al  B       A [ 1 ]  re al  C         B  C            A [ 0 ]  im ag  B       A [ 1 ]  im ag  C         B  C             
A   0     
1  6          A   
A   A  1   
s y m me tri c _ Point ( B , C )  A 
A  B    3   
A  B     1   
B      B 
( ' 0 '  ' 90 '  ' 1 80 '  ' 2 70 ' )    A 
' 0 '  A  B  C   
A  B    C  B    ' I '       A  B  1     
A  0     B  0     C  0     
A  15  B      15  2     3      B          
B  A    A 
( 0  4  13  27  4 5  6 7  9 4  12 6  16 2  20 2  24 7 )    A 
A  30   
( 0 )    C  1        ( 0 )    C  1        A  B 
A  0  9         B   in put ()            
B     ' A '        A 
B         A 
A  B    2     
A  B  2      ' a '     
0  C         B   A  B  1      
A . he ap push ( B , ( 0 , 0 , 0 , 1 ) )
com b i ( 2 )
A  B       B  1     2        
A  B    C  D     
A  B  1      C    0     
A  B       
0  10 2         C   0  10 2         B   0      A 
0  2         C   0  15         B   0      A 
C  D       A  B 
act ( 0 , 2 if A == ' i ' else 1 )
A  B  C       
A  2  B          
C  ed ge  D    C  ed ge  E    A  B 
2                         A 
' a '  ' b '  ' c '  ' d '  ' e '  A  11    A  12    A  13    A  14    A  15   
0  C  2           B   0    A 
                  A  B 
1  A  B  C   
D  2     1  E       E  A  B  1    C   
A  B    C     
A  0       
C  A  p ar  B   
B  30   A 
key  x    - x  1     A   
A  A      B  B        C  C          
C  D      D  A  B 
0  9          A   
0  E  1           D   0  C         B   0      A 
A     0 
A  B    A 
3 60  B  C       A 
0  D         C   C    A  B   
A  B  C         0    
A  B    ' ( '     
3 7  A 
A . he ap push ( B , ( C , D , E , F ) )
next _ per m u t ation ( A )      
c al c _ a re a ( A ) 
' A '  A 
re c ( A , B , 0 ) 
A  B  B            
             A   
( 0  0  1  4  10  20  3 5  5 6  8 4  1 20  16 5 )    A 
A  A      B       
( 4 14 12 12 1  14 12 12 14  4 12 12 14 1  12 12 14 14  2 12 14 14 1  12 14 14 12  2 14 14 12 1  14 14 12 12 )    A 
A  B  1    0    
                  A  B  C  D 
10 4 7 29  A 
A  ' p e ach '  ' app le '     A 
A  B  1         C  D  1         
( ( B , 2 )  ( C , 2 )  ( D , 3 )  ( E , 3 )  ( F , 1 )  ( G , 1 ) )    A 
3  0 x ff  2       A 
C  ' : '                A  B 
A  
( 0 )    1 28      A 
ro ot ( A )  ro ot ( B )     
A     1000 0000 01 
                       A  B  C 
1  B  1            A   
B  C       D  E          F  G          H  I         A 
B  2   A 
A   
[MASK]  [MASK]   
C  3                    A  B 
0 . 0000 1  B      A 
A  B   
' N o \ n ' 
A  C    
( A  C    A  B   )    ( A  B    A  C   )   
d i j k st ra ( C , D , C -1 )     A  B 
A  0    0    
A . he ap push ( B , ( C [ 1 ] , C [ 0 ] ) )
C  D   
A  B      0   
A  1      
5  B    2         A   
A  B    
B  g c d ( B , C )      C      A 
0.0 0 8 7 26 64 6 25 99 7 1 64 7 88 4 6 18 4 5 38 4 24 4  A 
E Q ( A , 4 )   
g c d ( A [ 0 ] , A [ 1 ] )  l c m ( A [ 0 ] , A [ 1 ] ) 
0  11         C   0  100 1         B   0      A 
B     A   
C  A  id  B   
A  B   
A     B  C     
A  B  C        B  D       E   
E  F      G  F      E  F    G  F   A  B  C  D 
( B  B  C  D     0     1             )    A 
A  B  2    1   
2 25  B  1      2         A   
0  C  1     A  B 
       
A  l evel  B    0    
0  5  B               A   
0  A  1  D  E  E     A  B  1  C  C   
c la use ( A [ 1 : -1 ] )   
  A   8      
0  12          A   
A  B  
0  21  B              A   
0.0 00 1  A 
A  1   B    
A  C    B  1   A  B 
( 10  12  15 )    A 
0  100 2         C   0  100 2         B   0      A 
0  A    1   
A  2   B  2    C  2      ' Y E S '   ' N O ' 
A  B      
re c ( A + 1, B + C , D + E )
A  B    
C  re al  D  re al   2      C  im ag  D  im ag   2     A  B 
( ( ' N or th ' , 1 )  ( ' E a st ' , 2 )  ( ' W est ' , 3 )  ( ' S out h ' , 4 )  ( ' R ight ' , 5 )  ( ' L e f t ' , 6 ) )    A 
1  A   B  3      B  3        
A  B    A  C      
' my on '  c al c ( A )      
0  21          A   
1  A  [MASK]   
A  B   ' O K '   ' NA ' 
      A  1    B  1          
A  B    C   
( 0 )    B      A  w s 
3  A     6   
A  B    C  1         
                   A  B  C  D  E  F 
ng c d ( B , C )  A 
A  B   C  B   
A  1      
E  A  2 * B  1      C      D      D   
A  A   A 
A     B  C  D            E  C  F            
( 0 )    100      A 
j u d ge ( A , B , C , D , E , F , G , H )   ' Y E S '   ' N O ' 
         A 
A  ' __ __ _ '  ' p e ach '     
A  B  C  D    A 
A  B  C        
B  C    B  C  1         A 
(1)    B      A  s ize 
A  0    ' ) '      
  ' , '           A  B  C 
A     ( ( 0  1  2  3  4  5  6  7 )    0 )   
A  ( ' + '  ' - '  ' * '  ' / ' )     
B  B      A 
C  D     1   B   A 
1966 6 6  A      B     
  ' , '                 A  B 
A  B          
A  100   
A     
1  3 1         B   B    A 
A   B  1       
  ' : '                 A  B 
A  2  
                A  B   
B  1    C  1            A   
A  ' U '   
B   B  4         B  3    B  1           A 
0  7          A   
A . un it e ( B [ 0 ] , B [ 1 ] )
             A  B  C 
A  B  C  D  D    10 0000      
A  B  C      ' Y '     
A  5  
D  ed ge  E  F       A  B  C 
A   ' y es '   ' no ' 
A  B  C   B  C          
B   1     A 
0  D  C  B     A 
A  50   B  A    0     B  A    C    
0     1       A 
A  B   
( ( 1,  600 0 )  ( 2 ,  400 0 )  ( 3 ,  300 0 )  ( 4 ,  2000 ) )    A 
A  B     A  B    
( 7 1.0  7 7.0  8 3.0  89 . 0  10 5.0  11 6.0  14 8.0  100 0.0 )    A 
A  0   B  0   A  9   B  9   
 con n ect ed  self  x  y     
0 x 7 ff ff ff f  A 
A  sh ort p a th ( B , C , D , E )   
 con n ect ed  self  p  q     
A  B  C      
            A  0   
                  A  B    C  B    D  B    E  B   
A  B   A   -1 
le ap _ y ear ( A )   
2002  A 
2  A     A 
get ( A ) 
A - B    C   A  B   A   ' im po s si ble ' 
1  12 6          A   
B  C   D   A 
A  B  1         
1  2  A  1    A  2   
0  B           A   
A . push ( B )
0  1  B  1                 A   
  A 
A  B  C  1      1   
10  B      C   A 
A  3 600      A  3 600       60      A  60      
0  1  A  B  0   
0  10 5         C   0  10 5         B   0      A 
 B  C     A 
B  im ag  C  im ag     2     A 
B   2       A 
A  B  p ow er  C    B . w e ight ( C )     
is P ar all el LL ( [ A , B ] , [ C , D ] )   ' Y E S '   ' N O ' 
A  B  C    ' 1 '     
B   A 
E Q ( A [ B ] . im ag , 0 )  E Q ( A [ C ] . im ag , 0 )   
A . he ap push ( B , ( 0 , C , - 1, 0 ) )
A  B        
4 2 80  A     
( 0 )    3      ( 0 )    3      ( 0 )    3      A  B  C 
A  B    ' 0 '      
A  1   B     C  B  A      C  B  A  1          
A  B  1    C    A  B  C    A  B  1    C   
    0  A  B 
0  B  4            A   
C  1    2  A  B 
B  C  3    0    c al c ( B [ C ] [ 3 ] )   1  A 
C  10    C  11    A  B 
1  D   A  B  C   
(1)    16      ( 0 )    16      A  B 
-1  A  B   
0  B  2              A            
0  27         C   0  27         B   0      A 
u t 2 j d ( A , B , C )  u t 2 j d ( D , E , F )     
k ru s k al ( A , B ) 
A  B   C       A 
A . con n ect ed ( B [ 0 ] , B [ 1 ] )   
A  B     C 
A  ' . '     
  ' 3 C '   A  ' 0 2 d '     
A  1   B    
B  C      D  E        A 
0  C         D   0  C         B   0      A 
  ' , '           A  B 
A     ( B  100      1      C  D )   
B   A   
A  B  1        C  B  1           A  B   
key  x    ( x   x  2   )     A   
A  1     1000      1   1000      A 
( 0.0 )    C      ( 0.0 )    C      A  B 
1  0  A  B 
A  0.5   A 
A         A  0    ' _ '         
A  B   
1  C   A  B 
B  C  1    D  E          A 
  A  3 600      ' : '  A  3 600       60      ' : '  A  60      
20  A 
                A 
A  B  C        
0  5          A   
0  1  A  B    C  B   
B    A 
( ( -1  -1 )    ( -1  0 )    ( -1  1 )    ( 0  -1 )    ( 0  1 )    ( 1  -1 )    ( 1  0 )    ( 1  1 )   )    A 
A  B     
A  B  C  1        0     
A  re al  2   A  im ag  2   
c al c ()  15   
          A 
           float     A 
A  100     1   B     
B  C     A   
A  B    A  C        
C  D  1         C  D  1      1      A  B 
A  l evel  C    1   A  l evel  B   
A  B + 2  C    ' # '     A  B + 1  C    ' # '     A  B  1    C  1        ' # '     
10  A      B  10        A 
3  3 1          A   
( 0 )    6 2      ( 0 )    6 2      A  B 
C   D  A  B 
0  A  l evel  B   
A  0    
A . con n ect ed ( B , C )   ' y es '   ' no ' 
A  B       A  B  1          
     B  0     A 
-1  0  A  B 
1000 0000 10  A 
( 0 )    500 1      A 
A  B   C  0     
0  100         C   0  100         B   0      A 
d i j k st ra ( B , C , D , E )  A 
( 0 )    3      ( 0 )    3      A  B 
B        A 
( 1 86 80 90 8  19 1 20 7 30  19 26 12 25  1989 0 10 8  99 99 99 99 )    A 
B  C -1  2    D      E     B  C  1         A 
100 0000  A 
' a '     ' z '     1   A  B 
A  B   C    A  B  C 
A  B  C  D      A 
' o ver f l ow ' 
A  1     
2  12          A   
B  0    A 
1  A  B  C        
A  B      
' d ' 
A < 0  B < 0  C  0    D  0    E  0    F  0    
0  10 1         D   0  10 1         C   B      A 
B  1      A 
A  B    C  D  A       
B  C  1      D         A   
10 0000  10 0000 0000  A  B 
   ' > '  A  B 
A  B    
A  [MASK]   A     
A  ' * '     
A     ( B  - C )   
E            A  B  C  D 
3  1  B  1           2         A   
B  0.5     A 
0  D    C  1   A  B  C 
18 2  A 
A     1 
A  
1  1  1  A  B  C 
C  ' . '          A  B 
A  B  1    0     
( 15 20  18 70  2 24 4 )    A 
  A  B      0    
A  B  1        C   
A  B    C  0    D  A    C    
( ( 0 ,  ' . ' )  ( 1,  ' E ' ) )    A 
A  math . s in ( B / A )      math . co s ( C * B / A )      math . co s ( ( C -1 ) * B / A )     
c al c ( 0 , 0 )  
1  D  D  A  B  C 
0  C  2           B       A 
B  C      C  D         A 
' k '  ' l '  ' m '  ' n '  ' o '  A  3 1    A  32    A  3 3    A  3 4    A  3 5   
0  B  2              A   
B  1    6          A   
D  E  F    A  B  C   
0  E         F   0  E         D   0  3 1         C   B        A 
200  F  E  D  C  B [ 0 ]       A  0   
do t ( B - C [ 0 ] , D )  no r m ( D )     A 
A  3       1   
 B  ' 0 8 b '     A 
A  B  C     
A    B    2      25   
B  C  D        E  D        B  C  D         F  D        G  D          A 
1  B           A   
     A   
2 
B . d f s ( C , D , E )  A 
A  B  C  D    B  C  E  1              
A       
-1  B   A 
A  B * C  D * E   4      5        
A  B  C     
d c m p ( c ro s s ( B [ 1 ]- B [ 0 ] , C [ D ]- B [ 0 ] ) )  A 
x    x  1       B            A 
B         A 
B  B  100 1            A   
2    
0  10         D   0  10         C   0  10         B   0        A 
A  B    A  C  B       
B  5       1     5   2  A 
B  1    C          A   
A   B       A 
(  )    11      A 
A    1      B    1     A  B 
A  B  0    C   C  A  B  1     
A  60   
0  C         B         A 
in s ide ( A , B , C , D , E , F )   
A . un it e ( B , C )
1  4          A   
B  C  D     A 
A  B  C    1   
g c d ( B [ 0 ] , B [ 1 ] )  A 
B  C  1      B         A   
( 0 )    0  C         B           A 
A  0    ' im po s si ble '   A 
f act or ()     A  B 
A  con ve x _ h ul l ( B )      
A  [MASK]   
( 500  100  50  10  5  1 )    A 
17  A 
( 0 )    200      0  A  B 
     A 
B  1  C         A 
0  4         D   0  8         C   0  8         B   0        A 
( 0 )    2      A 
                  A  B  C    D  B  C  1   
A  B   C  D   A  B   C  D   
A  B  C    1        D   
A  B      C  
A  B    ' 0 '         
get ( B )  A 
B  4   A 
B  C  2      1     A 
B  3   A 
D  A  B  C    0   
0  B  1              A   
-3  3  B  1    B  2           A 
A  0    A  B   C  0    C  D   E  A  C     
  ' , '         float        A  B 
A  B    C  1         
A  B      1   
A  1     
1  1  1  A   A  B    A  C   
B  C    1   A 
A  1   
Max F l ow ( B )  A 
   0  A  B 
10 e 8  A 
A  B  1      A  B    A  B    A  B  1     
1000 1  A 
A  B  1        1     A  B   
A  2   
A  B  C         
                  A  B  C  D  E  F 
B  0    -1         A   
A  B  3  C             A 
( 0 )    A  V      A  it er 
0  A  B   
push B ack ( A , B )
0  A 
1 e -8  A 
B  C    B  D  1           A 
A  ed ge  B  C  1    D   
A  1  [MASK]       
C  1   
A  1   B       
A  B   C    
B  C  1     A   
( 0 )    7      A 
A  ' 0 '     
com b i ( A + 1 )
A  1    
get ( C )  get ( D )  A  B 
A  30    
( 500  100  50  10  5  1 )    A 
B  1 0000      C  100        D   A 
A . he ap push ( B , ( C , D ) )
A     0     
A   ' O K '   ' N G ' 
A  9     
( 0  1  2  0  1  2  0  1  2 )    A 
A  B  C        
A  A  1   1        A 
1  2  A  B 
            A  B  C  D  E 
x    ( x  im ag  x  re al )       B      A 
' # '  A  B  C   
A  1.0       B   A  1.0   
0  20          A   
0  5 1  B        C  D           A   
B  3    A 
D    C   B  C    D      B   B  C     A 
6 3 78 . 1  math . ac os ( A )      0.5    
B  re al  C  re al     A 
( 0 )    32      A 
p ay ( B )  A 
1  100          A   
12  12      A 
A  B  A           
B  C    A 
1  B   A 
A  1       
0  D         E   0  1  D              C   B      A 
A  B  C  D  E    10 0000      
A     
A  B    2    
A  B  C       D  0     
A  B  C    A  B  D    A  D  C       A  B  C   
A . add _ ed ge ( B , C , 1 )
0  16          A   
B  1    B      A 
A  B  1        C  B     A  B   
A  B    C  D       
0  E         C   B  C  D      A 
D  B  A  B    C 
A  B  1        A  B    1     
0  6         C   0  6         B   0      A 
A  1  B   
A  1     B   
- A  B   B  A   
 c ro s s  a  b     
A  B    A  C       D       
A  B    C    D  B    E    F  B    G    H  I    
0  20 1         C   0  20 1         B   0      A 
A  B    0     A  C    0     
get In t ()  A  B   
A         A         
1  B     A 
  0  D   A  B  C 
' 2 '  A  B  C   
A     ( 0  B  C )   
A  B  C  2        D  C  1         A  B  1    C  1       
A  ' + '      A  ' - '      
A  B     
1  13          A   
A  -1     B  -1     C  -1     D  -1     
A  B        
1  A   B    
A  10    
B   C  D     B  0     A  0   
A     ( B  C  D )   
(  )    B      A 
E Q ( A . im ag , B . im ag )   
3 1  9      5  5        1   A 
C  1      1  A  B 
( ( 0  0  0  0 )   )    A 
A  ' END O F  IN P UT '     
A  B   
A  B  C   
L IS ( A ) 
C     C    A  B 
            A  B 
0  G         F   0  E         D   0  4         C   B        A 
j u d ge ( s ort ed ( A ) , s ort ed ( B . it em s () , key = lambda x : - C [ 1 ] ) ) 
  A  2   
0  -1  A  B 
A  B  C       ( B  D    E  D  C      1       )   
A   
A . he ap push ( B , ( C + v abs ( D [ E ]- D [ F ] ) , F , D [ F ] . re al ) )
0  5         F             A  B  C  D  E 
C    B   B  D     B    A 
  ' C as e  '  A  1    ' : ' 
C  D     A  B   
B   C  2         A 
A   ' . '       0    
A  B  C      A  D       
A   A 
A  ' L '   
( ( ' s ' , 1 )  ( ' w ' , 2 )  ( ' e ' , 3 )  ( ' n ' , 4 ) )    A 
A     [MASK]   
A  B   1     
D  1   
( 0 )    10 1      A 
B   C       A 
A  B  C      A 
A  B  0    A  C  0      A  B  1    A  C  1      D  C    E    
math . ac os ( ( B * B + C * C - D * D ) / ( 2 * B * C ) )  A 
( ' A A A '  ' A A '  ' A '  ' B '  ' C '  ' D '  ' E '  ' NA ' )    A 
B  C      D  E         F  G         H  I        A 
A  B  0    C    A  B  1    0   
A     B 
A  1   1      
A  2  B        
B  C    D  E       A 
A  B   1        
( 0 )    B      A  l evel 
s ie ve ()
( -1 )    400 1      A 
A   ' Y E S '   ' N O ' 
A     B  1   
    A  B 
B     C        A 
A   B       A  B    C           -1       A  C           A 
A  2  B         
B  C  1            A   
B  C  D  E    A 
A  B  1         
      B  C       A 
                   A 
     A    A  1    A  B  2       
A   
0  1  B               A   
A  0    B  A    
A  B  C  D         E   
A  B  1      A  B     A  B     A  B  1     
A     B  
  0  A  B 
1  A   
           float       A  B  C 
def a ul t d ic t ( B )  A 
(  )    2      A 
A  B  C  1           D    
A  0     B  0     
key  x    ( - B  2    x  3    x  )     A   
B  C    D     A 
B  C      D  E        F  G        A 
A  B     3    
A                A 
A  ' > '     
2 23  A 
1  C  B    A 
( int ) ( B * C )  A 
A  B  1    A  B  1      1       
A  A      100      1 0000       A 
D  A  B  1      C      C   
  A  1   
A  B  0    0    
- B  C    D  C    A 
A    B   B     C       A 
' p '  ' q '  ' r '  ' s '  ' t '  A  4 1    A  4 2    A  4 3    A  4 4    A  4 5   
0  5         C   0  5         B   0      A 
U n ion S et ( B * C )  A 
B  11    A 
99 7  B    2         A   
A   B    A  1  B   
  A  B      1     
[MASK]  A  B  C       
10  A 
A  B   3      
0  C         B                     A 
3  3  D  2     A  B  C 
C  A  B  0   
A  B  C    B  D  1           
A  B  C  D  E    A  B  1      C  D  D     
A  B  C        0     
D                   A  B  C 
A  5  B        
A          
A  B    ' a '     
A  0    -1   B 
A  B    c ro s s ( C [ A -1 ]- C [ A -2 ] , D [ E ]- C [ A -1 ] )  0       
   A 
d i j k st ra ( C , D , 0 )     A  B 
B   2     A 
A    A   1   
A  100    
A  B  1         C  1     
D   D  1    E   A  B  C 
B  2  A         A 
  A 
( int ) ( A * * 2 / 19 . 6 )  5      2   
A  B  C  1      B  C  0    A    
  A  B   
A  B  C        
500  A 
B  C   1      A 
A  B  p ow er  C    B . w e ight ( C )     
A  B  C    D   A  B  E     
C  D    E  D    A  B 
com b i ( 2 , A , B [ C ] [ 2 ] )
A  1   B    C  A    A  2       ' IO '     
( 3 80  5 50  8 50 )    A 
b is ect _ left ( B , C , 0 )  1     A 
D     A  B  C 
A  1   
B  C  D      A 
A  B      
0  4 5         B        A 
( 1  5  25  1 25  6 25  3 1 25  15 6 25  78 1 25 )    A 
( 0 )    0  C  1             B           ( D )     A 
A  2     
A  B    A  B  1           C   
0  2         C   0  7         B   B      A 
0  100 2         B   (  )      A 
[MASK]  1     
pars e ( A , B [ C ] [ 1 ] )
B    C         4   ' 0 '      A 
[MASK]  A 
A  B  1   
A  -10    
g c d ( C , D )  g c d ( E , D )  A  B 
A  B  C  2        ' # '     A  B  C  1        ' # '     A  B  1      C  1        ' # '     
A | B  C     D     E     F     0     
B  re al  C  re al     2     A 
0  4         B             A 
F  A     E 
A  B    B  A    C   0     
B  C          A   
( B  C )    A  F ( ' t ' )  F ( ' h ' )   F ( ' a ' )   F ( ' t ' )     
A  B    0   
( -1  0  1  0 )    A 
D  0       A  B  C 
D     ' A '         E     ' A '         F     ' A '        A  B  C 
B  C    D  C     2      E  C    3        E  C     A 
B  C  1    -1    -1         A   
C  A  B  1   
 E Q  a  b     
B  5   A 
( B )    C  2        A 
A  1  [MASK]        C    A  [MASK]  D  1           
( 0 )    1 20      0  A  B 
0  B          A   
B  id  A    A 
